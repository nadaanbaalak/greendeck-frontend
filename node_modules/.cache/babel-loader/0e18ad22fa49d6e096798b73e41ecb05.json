{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findPopoverPosition = findPopoverPosition;\nexports.getPopoverScreenCoordinates = getPopoverScreenCoordinates;\nexports.getElementBoundingBox = getElementBoundingBox;\nexports.getAvailableSpace = getAvailableSpace;\nexports.getVisibleFit = getVisibleFit;\nexports.intersectBoundingBoxes = intersectBoundingBoxes;\nexports.getElementZIndex = getElementZIndex;\nexports.POSITIONS = void 0;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\nvar POSITIONS = ['top', 'right', 'bottom', 'left'];\nexports.POSITIONS = POSITIONS;\nvar relatedDimension = {\n  top: 'height',\n  right: 'width',\n  bottom: 'height',\n  left: 'width'\n};\nvar dimensionPositionAttribute = {\n  height: 'top',\n  width: 'left'\n};\nvar positionComplements = {\n  top: 'bottom',\n  right: 'left',\n  bottom: 'top',\n  left: 'right'\n}; // always resolving to top/left is taken advantage of by knowing they are the\n// minimum edges of the bounding box\n\nvar positionSubstitutes = {\n  top: 'left',\n  right: 'top',\n  bottom: 'left',\n  left: 'top'\n};\n/**\n * Calculates the absolute positioning (relative to document.body) to place a popover element\n *\n * @param anchor {HTMLElement} Element to anchor the popover to\n * @param popover {HTMLElement} Element containing the popover content\n * @param position {string} Position the user wants. One of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param [forcePosition] {boolean} If true, use only the provided `position` value and don't try any other position\n * @param [align] {string} Cross-axis alignment. One of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param [buffer=16] {number} Minimum distance between the popover and the bounding container\n * @param [offset=0] {number} Distance between the popover and the anchor\n * @param [allowCrossAxis=true] {boolean} Whether to allow the popover to be positioned on the cross-axis\n * @param [container] {HTMLElement} Element the popover must be constrained to fit within\n * @param [arrowConfig] {{arrowWidth: number, arrowBuffer: number}} If\n *  present, describes the size & constraints for an arrow element, and the\n *  function return value will include an `arrow` param with position details\n *\n * @returns {FindPopoverPositionResult} absolute page coordinates for the\n * popover, and the placement's relation to the anchor or undefined\n * there's no room.\n */\n\nfunction findPopoverPosition(_ref) {\n  var anchor = _ref.anchor,\n      popover = _ref.popover,\n      align = _ref.align,\n      position = _ref.position,\n      forcePosition = _ref.forcePosition,\n      _ref$buffer = _ref.buffer,\n      buffer = _ref$buffer === void 0 ? 16 : _ref$buffer,\n      _ref$offset = _ref.offset,\n      offset = _ref$offset === void 0 ? 0 : _ref$offset,\n      _ref$allowCrossAxis = _ref.allowCrossAxis,\n      allowCrossAxis = _ref$allowCrossAxis === void 0 ? true : _ref$allowCrossAxis,\n      container = _ref.container,\n      arrowConfig = _ref.arrowConfig,\n      returnBoundingBox = _ref.returnBoundingBox; // find the screen-relative bounding boxes of the anchor, popover, and container\n\n  var anchorBoundingBox = getElementBoundingBox(anchor);\n  var popoverBoundingBox = getElementBoundingBox(popover); // calculate the window's bounds\n  // window.(innerWidth|innerHeight) do not account for scrollbars\n  // so prefer the clientWidth/clientHeight of the DOM if available\n\n  var documentWidth = document.documentElement.clientWidth || window.innerWidth;\n  var documentHeight = document.documentElement.clientHeight || window.innerHeight;\n  var windowBoundingBox = {\n    top: 0,\n    right: documentWidth,\n    bottom: documentHeight,\n    left: 0,\n    height: documentHeight,\n    width: documentWidth\n  }; // if no container element is given fall back to using the window viewport\n\n  var containerBoundingBox = container ? getElementBoundingBox(container) : windowBoundingBox;\n  /**\n   * `position` was specified by the function caller and is a strong hint\n   * as to the preferred location of the popover relative to the anchor.\n   * However, we strongly prefer showing all of the popover content within\n   * the window+container boundary and will iterate over the four\n   * possible sides until a perfect fit is located. If none of the locations\n   * fully contain popover, the location with the best fit is selected.\n   *\n   * This approach first checks the preferred `position`, then its opposite\n   * along the same axis, next a location on the cross-axis, and finally it\n   * tests the remaining position.\n   *\n   * e.g.\n   * if position = \"top\" the order is top, bottom, left right\n   * if position = \"right\" the order is right, left, top, bottom\n   */\n  // Try the user-desired position first.\n\n  var iterationPositions = [position]; // keep user-defined alignment in the original positions.\n\n  var iterationAlignments = [align];\n\n  if (forcePosition !== true) {\n    iterationPositions.push(positionComplements[position]); // Try the complementary position.\n\n    iterationAlignments.push(align); // keep user-defined alignment in the complementary position.\n\n    if (allowCrossAxis) {\n      iterationPositions.push(positionSubstitutes[position], // Switch to the cross axis.\n      positionComplements[positionSubstitutes[position]] // Try the complementary position on the cross axis.\n      );\n      iterationAlignments.push(undefined, undefined); // discard desired alignment on cross-axis\n    }\n  } else {\n    // position is forced, if it conflicts with the alignment then reset align to `null`\n    // e.g. original placement request for `downLeft` is moved to the `left` side, future calls\n    // will position and align `left`, and `leftLeft` is not a valid placement\n    if (position === align || align !== undefined && position === positionComplements[align]) {\n      iterationAlignments[0] = undefined;\n    }\n  }\n\n  var bestFit = undefined;\n  var bestPosition = null;\n\n  for (var idx = 0; idx < iterationPositions.length; idx++) {\n    var iterationPosition = iterationPositions[idx]; // See if we can find a position with a better fit than we've found so far.\n\n    var screenCoordinates = getPopoverScreenCoordinates({\n      position: iterationPosition,\n      align: iterationAlignments[idx],\n      anchorBoundingBox: anchorBoundingBox,\n      popoverBoundingBox: popoverBoundingBox,\n      windowBoundingBox: windowBoundingBox,\n      containerBoundingBox: containerBoundingBox,\n      offset: offset,\n      buffer: buffer,\n      arrowConfig: arrowConfig\n    });\n\n    if (bestFit === undefined || screenCoordinates.fit > bestFit) {\n      bestFit = screenCoordinates.fit;\n      bestPosition = {\n        fit: screenCoordinates.fit,\n        position: iterationPosition,\n        top: screenCoordinates.top + window.pageYOffset,\n        left: screenCoordinates.left + window.pageXOffset,\n        arrow: screenCoordinates.arrow\n      }; // If we've already found the ideal fit, use that position.\n\n      if (bestFit === 1) {\n        break;\n      }\n    } // If we haven't improved the fit, then continue on and try a new position.\n\n  }\n\n  if (bestPosition == null) {\n    throw new Error('Failed to calculate bestPosition');\n  }\n\n  if (returnBoundingBox) {\n    bestPosition.anchorBoundingBox = anchorBoundingBox;\n  }\n\n  return bestPosition;\n}\n/**\n * Given a target position and the popover's surrounding context, returns either an\n * object with {top, left} screen coordinates or `null` if it's not possible to show\n * content in the target position\n * @param position {string} the target position, one of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param align {string} target alignment on the cross-axis, one of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param anchorBoundingBox {Object} bounding box of the anchor element\n * @param popoverBoundingBox {Object} bounding box of the popover element\n * @param windowBoundingBox {Object} bounding box of the window\n * @param containerBoundingBox {Object} bounding box of the container\n * @param [arrowConfig] {{arrowWidth: number, arrowBuffer: number}} If present, describes the size &\n *  constraints for an arrow element, and the function return value will include an `arrow` param\n *  with position details\n * @param [offset=0] {number} Distance between the popover and the anchor\n * @param [buffer=0] {number} Minimum distance between the popover's\n *  placement and the container edge\n *\n * @returns {GetPopoverScreenCoordinatesResult}\n *  object with top/left coordinates, the popover's relative position to the anchor, and how well the\n *  popover fits in the location (0.0 -> 1.0) coordinates and the popover's relative position, if\n *  there is no room in this placement then null\n */\n\n\nfunction getPopoverScreenCoordinates(_ref2) {\n  var _popoverPlacement, _ref3;\n\n  var position = _ref2.position,\n      align = _ref2.align,\n      anchorBoundingBox = _ref2.anchorBoundingBox,\n      popoverBoundingBox = _ref2.popoverBoundingBox,\n      windowBoundingBox = _ref2.windowBoundingBox,\n      containerBoundingBox = _ref2.containerBoundingBox,\n      arrowConfig = _ref2.arrowConfig,\n      _ref2$offset = _ref2.offset,\n      offset = _ref2$offset === void 0 ? 0 : _ref2$offset,\n      _ref2$buffer = _ref2.buffer,\n      buffer = _ref2$buffer === void 0 ? 0 : _ref2$buffer;\n  /**\n   * The goal is to find the best way to align the popover content\n   * on the given side of the anchor element. The popover prefers\n   * centering on the anchor but can shift along the cross-axis as needed.\n   *\n   * We return the top/left coordinates that best fit the popover inside\n   * the given boundaries, and also return the `fit` value which indicates\n   * what percentage of the popover is within the bounds.\n   *\n   * e.g. finding a location when position=top\n   * the preferred location is directly over the anchor\n   *\n   *        +----------------------+\n   *        |       popover        |\n   *        +----------------------+\n   *                   v\n   *            +--------------+\n   *            |    anchor    |\n   *            +--------------+\n   *\n   * but if anchor doesn't have much (or any) room on its ride side\n   * the popover will shift to the left\n   *\n   *    +----------------------+\n   *    |       popover        |\n   *    +----------------------+\n   *                   v\n   *            +--------------+\n   *            |    anchor    |\n   *            +--------------+\n   *\n   */\n\n  var crossAxisFirstSide = positionSubstitutes[position]; // \"top\" -> \"left\"\n\n  var crossAxisSecondSide = positionComplements[crossAxisFirstSide]; // \"left\" -> \"right\"\n\n  var crossAxisDimension = relatedDimension[crossAxisFirstSide]; // \"left\" -> \"width\"\n\n  var _getCrossAxisPosition = getCrossAxisPosition({\n    crossAxisFirstSide: crossAxisFirstSide,\n    crossAxisSecondSide: crossAxisSecondSide,\n    crossAxisDimension: crossAxisDimension,\n    position: position,\n    align: align,\n    buffer: buffer,\n    offset: offset,\n    windowBoundingBox: windowBoundingBox,\n    containerBoundingBox: containerBoundingBox,\n    popoverBoundingBox: popoverBoundingBox,\n    anchorBoundingBox: anchorBoundingBox,\n    arrowConfig: arrowConfig\n  }),\n      crossAxisPosition = _getCrossAxisPosition.crossAxisPosition,\n      crossAxisArrowPosition = _getCrossAxisPosition.crossAxisArrowPosition;\n\n  var primaryAxisDimension = relatedDimension[position]; // \"top\" -> \"height\"\n\n  var primaryAxisPositionName = dimensionPositionAttribute[primaryAxisDimension]; // \"height\" -> \"top\"\n\n  var _getPrimaryAxisPositi = getPrimaryAxisPosition({\n    position: position,\n    offset: offset,\n    popoverBoundingBox: popoverBoundingBox,\n    anchorBoundingBox: anchorBoundingBox,\n    arrowConfig: arrowConfig\n  }),\n      primaryAxisPosition = _getPrimaryAxisPositi.primaryAxisPosition,\n      primaryAxisArrowPosition = _getPrimaryAxisPositi.primaryAxisArrowPosition;\n\n  var popoverPlacement = (_popoverPlacement = {}, _defineProperty(_popoverPlacement, crossAxisFirstSide, crossAxisPosition), _defineProperty(_popoverPlacement, primaryAxisPositionName, primaryAxisPosition), _popoverPlacement); // calculate the fit of the popover in this location\n  // fit is in range 0.0 -> 1.0 and is the percentage of the popover which is visible in this location\n\n  var combinedBoundingBox = intersectBoundingBoxes(windowBoundingBox, containerBoundingBox); // shrink the visible bounding box by `buffer`\n  // to compute a fit value\n\n  combinedBoundingBox.top += buffer;\n  combinedBoundingBox.right -= buffer;\n  combinedBoundingBox.bottom -= buffer;\n  combinedBoundingBox.left += buffer;\n  var fit = getVisibleFit({\n    top: popoverPlacement.top,\n    right: popoverPlacement.left + popoverBoundingBox.width,\n    bottom: popoverPlacement.top + popoverBoundingBox.height,\n    left: popoverPlacement.left,\n    width: popoverBoundingBox.width,\n    height: popoverBoundingBox.height\n  }, combinedBoundingBox);\n  var arrow = arrowConfig ? (_ref3 = {}, _defineProperty(_ref3, crossAxisFirstSide, crossAxisArrowPosition - popoverPlacement[crossAxisFirstSide]), _defineProperty(_ref3, primaryAxisPositionName, primaryAxisArrowPosition), _ref3) : undefined;\n  return {\n    fit: fit,\n    top: popoverPlacement.top,\n    left: popoverPlacement.left,\n    arrow: arrow ? {\n      left: arrow.left,\n      top: arrow.top\n    } : undefined\n  };\n}\n\nfunction getCrossAxisPosition(_ref4) {\n  var crossAxisFirstSide = _ref4.crossAxisFirstSide,\n      crossAxisSecondSide = _ref4.crossAxisSecondSide,\n      crossAxisDimension = _ref4.crossAxisDimension,\n      position = _ref4.position,\n      align = _ref4.align,\n      buffer = _ref4.buffer,\n      offset = _ref4.offset,\n      windowBoundingBox = _ref4.windowBoundingBox,\n      containerBoundingBox = _ref4.containerBoundingBox,\n      popoverBoundingBox = _ref4.popoverBoundingBox,\n      anchorBoundingBox = _ref4.anchorBoundingBox,\n      arrowConfig = _ref4.arrowConfig; // how much of the popover overflows past either side of the anchor if its centered\n\n  var popoverSizeOnCrossAxis = popoverBoundingBox[crossAxisDimension];\n  var anchorSizeOnCrossAxis = anchorBoundingBox[crossAxisDimension];\n  var anchorHalfSize = anchorSizeOnCrossAxis / 2; // the popover's original position on the cross-axis is determined by:\n\n  var crossAxisPositionOriginal = anchorBoundingBox[crossAxisFirstSide] + // where the anchor is located\n  anchorHalfSize - // plus half anchor dimension\n  popoverSizeOnCrossAxis / 2; // less half the popover dimension\n  // To fit the content within both the window and container,\n  // compute the smaller of the two spaces along each edge\n\n  var combinedBoundingBox = intersectBoundingBoxes(windowBoundingBox, containerBoundingBox);\n  var availableSpace = getAvailableSpace(anchorBoundingBox, combinedBoundingBox, buffer, offset, position);\n  var minimumSpace = arrowConfig ? arrowConfig.arrowBuffer : 0;\n  var contentOverflowSize = (popoverSizeOnCrossAxis - anchorSizeOnCrossAxis) / 2;\n  var alignAmount = 0;\n  var alignDirection = 1;\n  var amountOfShiftNeeded = 0;\n  var shiftDirection = 1;\n\n  if (align != null) {\n    // no alignment, find how much the container boundary requires the content to shift\n    alignDirection = align === 'top' || align === 'left' ? 1 : -1;\n    alignAmount = contentOverflowSize;\n    var alignedOverflowAmount = contentOverflowSize + alignAmount;\n    var needsShift = alignedOverflowAmount > availableSpace[positionComplements[align]];\n    amountOfShiftNeeded = needsShift ? alignedOverflowAmount - availableSpace[positionComplements[align]] : 0;\n    shiftDirection = -1 * alignDirection;\n  } else {\n    // shifting the popover to one side may yield a better fit\n    var spaceAvailableOnFirstSide = availableSpace[crossAxisFirstSide];\n    var spaceAvailableOnSecondSide = availableSpace[crossAxisSecondSide];\n    var isShiftTowardFirstSide = spaceAvailableOnFirstSide > spaceAvailableOnSecondSide;\n    shiftDirection = isShiftTowardFirstSide ? -1 : 1; // determine which direction has more room and the popover should shift to\n\n    var leastAvailableSpace = Math.min(spaceAvailableOnFirstSide, spaceAvailableOnSecondSide);\n\n    var _needsShift = contentOverflowSize > leastAvailableSpace;\n\n    amountOfShiftNeeded = _needsShift ? contentOverflowSize - leastAvailableSpace : 0;\n  } // shift over the popover if necessary\n\n\n  var shiftAmount = amountOfShiftNeeded * shiftDirection;\n  var crossAxisPosition = crossAxisPositionOriginal + shiftAmount + alignAmount * alignDirection; // if an `arrowConfig` is specified, find where to position the arrow\n\n  var crossAxisArrowPosition;\n\n  if (arrowConfig) {\n    var arrowWidth = arrowConfig.arrowWidth;\n    crossAxisArrowPosition = anchorBoundingBox[crossAxisFirstSide] + anchorHalfSize - arrowWidth / 2; // make sure there's enough buffer around the arrow\n    // by calculating how how much the arrow would need to move\n    // but instead of moving the arrow, shift the popover content\n\n    if (crossAxisArrowPosition < crossAxisPosition + minimumSpace) {\n      // arrow is too close to the minimum side\n      var difference = crossAxisPosition + minimumSpace - crossAxisArrowPosition;\n      crossAxisPosition -= difference;\n    } else if (crossAxisArrowPosition + minimumSpace + arrowWidth > crossAxisPosition + popoverSizeOnCrossAxis) {\n      // arrow is too close to the maximum side\n      var edge = crossAxisPosition + popoverSizeOnCrossAxis;\n\n      var _difference = crossAxisArrowPosition - (edge - minimumSpace - arrowWidth);\n\n      crossAxisPosition += _difference;\n    }\n  }\n\n  return {\n    crossAxisPosition: crossAxisPosition,\n    crossAxisArrowPosition: crossAxisArrowPosition\n  };\n}\n\nfunction getPrimaryAxisPosition(_ref5) {\n  var position = _ref5.position,\n      offset = _ref5.offset,\n      popoverBoundingBox = _ref5.popoverBoundingBox,\n      anchorBoundingBox = _ref5.anchorBoundingBox,\n      arrowConfig = _ref5.arrowConfig; // if positioning to the top or left, the target position decreases\n  // from the anchor's top or left, otherwise the position adds to the anchor's\n\n  var isOffsetDecreasing = position === 'top' || position === 'left';\n  var primaryAxisDimension = relatedDimension[position]; // \"top\" -> \"height\"\n\n  var popoverSizeOnPrimaryAxis = popoverBoundingBox[primaryAxisDimension]; // start at the top or left edge of the anchor element\n\n  var primaryAxisPositionName = dimensionPositionAttribute[primaryAxisDimension]; // \"height\" -> \"top\"\n\n  var anchorEdgeOrigin = anchorBoundingBox[primaryAxisPositionName]; // find the popover position on the primary axis\n\n  var anchorSizeOnPrimaryAxis = anchorBoundingBox[primaryAxisDimension];\n  var primaryAxisOffset = isOffsetDecreasing ? popoverSizeOnPrimaryAxis : anchorSizeOnPrimaryAxis;\n  var contentOffset = (offset + primaryAxisOffset) * (isOffsetDecreasing ? -1 : 1);\n  var primaryAxisPosition = anchorEdgeOrigin + contentOffset;\n  var primaryAxisArrowPosition;\n\n  if (arrowConfig) {\n    primaryAxisArrowPosition = isOffsetDecreasing ? popoverSizeOnPrimaryAxis : 0;\n  }\n\n  return {\n    primaryAxisPosition: primaryAxisPosition,\n    primaryAxisArrowPosition: primaryAxisArrowPosition\n  };\n}\n/**\n * Finds the client pixel coordinate of each edge for the element's bounding box,\n * and the bounding box's width & height\n *\n * @param {HTMLElement} element\n * @returns {{top: number, right: number, bottom: number, left: number, height: number, width: number}}\n */\n\n\nfunction getElementBoundingBox(element) {\n  var rect = element.getBoundingClientRect();\n  return {\n    top: rect.top,\n    right: rect.right,\n    bottom: rect.bottom,\n    left: rect.left,\n    height: rect.height,\n    width: rect.width\n  };\n}\n/**\n * Calculates the available content space between anchor and container\n *\n * @param {Object} anchorBoundingBox Client bounding box of the anchor element\n * @param {Object} containerBoundingBox Client bounding box of the container element\n * @param {number} buffer Minimum distance between the popover and the bounding container\n * @param {number} offset Distance between the popover and the anchor\n * @param {string} offsetSide Side the offset needs to be applied to, one\n *  of [\"top\", \"right\", \"bottom\", \"left\"]\n * @returns {{top: number, right: number, bottom: number, left: number}}\n */\n\n\nfunction getAvailableSpace(anchorBoundingBox, containerBoundingBox, buffer, offset, offsetSide) {\n  return {\n    top: anchorBoundingBox.top - containerBoundingBox.top - buffer - (offsetSide === 'top' ? offset : 0),\n    right: containerBoundingBox.right - anchorBoundingBox.right - buffer - (offsetSide === 'right' ? offset : 0),\n    bottom: containerBoundingBox.bottom - anchorBoundingBox.bottom - buffer - (offsetSide === 'bottom' ? offset : 0),\n    left: anchorBoundingBox.left - containerBoundingBox.left - buffer - (offsetSide === 'left' ? offset : 0)\n  };\n}\n/**\n * Computes the fit (overlap) of the content within the container, fit is in range 0.0 => 1.0\n * @param contentBoundingBox bounding box of content to calculate fit for\n * @param containerBoundingBox bounding box of container\n * @returns {number}\n */\n\n\nfunction getVisibleFit(contentBoundingBox, containerBoundingBox) {\n  var intersection = intersectBoundingBoxes(contentBoundingBox, containerBoundingBox);\n\n  if (intersection.left > intersection.right || intersection.top > intersection.top) {\n    // there is no intersection, the boxes are completely separated on at least one axis\n    return 0;\n  }\n\n  var intersectionArea = (intersection.right - intersection.left) * (intersection.bottom - intersection.top);\n  var contentArea = (contentBoundingBox.right - contentBoundingBox.left) * (contentBoundingBox.bottom - contentBoundingBox.top);\n  return intersectionArea / contentArea;\n}\n/**\n * Calculates the intersection space between two bounding boxes\n *\n * @param firstBox\n * @param secondBox\n * @returns {EuiClientRect}\n */\n\n\nfunction intersectBoundingBoxes(firstBox, secondBox) {\n  var top = Math.max(firstBox.top, secondBox.top);\n  var right = Math.min(firstBox.right, secondBox.right);\n  var bottom = Math.min(firstBox.bottom, secondBox.bottom);\n  var left = Math.max(firstBox.left, secondBox.left);\n  var height = Math.max(bottom - top, 0);\n  var width = Math.max(right - left, 0);\n  return {\n    top: top,\n    right: right,\n    bottom: bottom,\n    left: left,\n    height: height,\n    width: width\n  };\n}\n/**\n * Returns the top-most defined z-index in the element's ancestor hierarchy\n * relative to the `target` element; if no z-index is defined, returns 0\n * @param element {HTMLElement}\n * @param cousin {HTMLElement}\n * @returns {number}\n */\n\n\nfunction getElementZIndex(element, cousin) {\n  /**\n   * finding the z-index of `element` is not the full story\n   * its the CSS stacking context that is important\n   * take this DOM for example:\n   * body\n   *   section[z-index: 1000]\n   *     p[z-index: 500]\n   *       button\n   *   div\n   *\n   * what z-index does the `div` need to display next to `button`?\n   * the `div` and `section` are where the stacking context splits\n   * so `div` needs to copy `section`'s z-index in order to\n   * appear next to / over `button`\n   *\n   * calculate this by starting at `button` and finding its offsetParents\n   * then walk the parents from top -> down until the stacking context\n   * split is found, or if there is no split then a specific z-index is unimportant\n   */\n  // build the array of the element + its offset parents\n  var nodesToInspect = [];\n\n  while (true) {\n    nodesToInspect.push(element); // AFAICT this is a valid cast - the libdefs appear wrong\n\n    element = element.offsetParent; // stop if there is no parent\n\n    if (element == null) {\n      break;\n    } // stop if the parent contains the related element\n    // as this is the z-index ancestor\n\n\n    if (element.contains(cousin)) {\n      break;\n    }\n  } // reverse the nodes to walk from top -> element\n\n\n  nodesToInspect.reverse();\n\n  for (var _i = 0, _nodesToInspect = nodesToInspect; _i < _nodesToInspect.length; _i++) {\n    var node = _nodesToInspect[_i]; // get this node's z-index css value\n\n    var zIndex = window.document.defaultView.getComputedStyle(node).getPropertyValue('z-index'); // if the z-index is not a number (e.g. \"auto\") return null, else the value\n\n    var parsedZIndex = parseInt(zIndex, 10);\n\n    if (!isNaN(parsedZIndex)) {\n      return parsedZIndex;\n    }\n  }\n\n  return 0;\n}","map":{"version":3,"sources":["/home/nadaanbaalak/greendeck/client/node_modules/@elastic/eui/lib/services/popover/popover_positioning.js"],"names":["Object","defineProperty","exports","value","findPopoverPosition","getPopoverScreenCoordinates","getElementBoundingBox","getAvailableSpace","getVisibleFit","intersectBoundingBoxes","getElementZIndex","POSITIONS","_defineProperty","obj","key","enumerable","configurable","writable","relatedDimension","top","right","bottom","left","dimensionPositionAttribute","height","width","positionComplements","positionSubstitutes","_ref","anchor","popover","align","position","forcePosition","_ref$buffer","buffer","_ref$offset","offset","_ref$allowCrossAxis","allowCrossAxis","container","arrowConfig","returnBoundingBox","anchorBoundingBox","popoverBoundingBox","documentWidth","document","documentElement","clientWidth","window","innerWidth","documentHeight","clientHeight","innerHeight","windowBoundingBox","containerBoundingBox","iterationPositions","iterationAlignments","push","undefined","bestFit","bestPosition","idx","length","iterationPosition","screenCoordinates","fit","pageYOffset","pageXOffset","arrow","Error","_ref2","_popoverPlacement","_ref3","_ref2$offset","_ref2$buffer","crossAxisFirstSide","crossAxisSecondSide","crossAxisDimension","_getCrossAxisPosition","getCrossAxisPosition","crossAxisPosition","crossAxisArrowPosition","primaryAxisDimension","primaryAxisPositionName","_getPrimaryAxisPositi","getPrimaryAxisPosition","primaryAxisPosition","primaryAxisArrowPosition","popoverPlacement","combinedBoundingBox","_ref4","popoverSizeOnCrossAxis","anchorSizeOnCrossAxis","anchorHalfSize","crossAxisPositionOriginal","availableSpace","minimumSpace","arrowBuffer","contentOverflowSize","alignAmount","alignDirection","amountOfShiftNeeded","shiftDirection","alignedOverflowAmount","needsShift","spaceAvailableOnFirstSide","spaceAvailableOnSecondSide","isShiftTowardFirstSide","leastAvailableSpace","Math","min","_needsShift","shiftAmount","arrowWidth","difference","edge","_difference","_ref5","isOffsetDecreasing","popoverSizeOnPrimaryAxis","anchorEdgeOrigin","anchorSizeOnPrimaryAxis","primaryAxisOffset","contentOffset","element","rect","getBoundingClientRect","offsetSide","contentBoundingBox","intersection","intersectionArea","contentArea","firstBox","secondBox","max","cousin","nodesToInspect","offsetParent","contains","reverse","_i","_nodesToInspect","node","zIndex","defaultView","getComputedStyle","getPropertyValue","parsedZIndex","parseInt","isNaN"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findPopoverPosition = findPopoverPosition;\nexports.getPopoverScreenCoordinates = getPopoverScreenCoordinates;\nexports.getElementBoundingBox = getElementBoundingBox;\nexports.getAvailableSpace = getAvailableSpace;\nexports.getVisibleFit = getVisibleFit;\nexports.intersectBoundingBoxes = intersectBoundingBoxes;\nexports.getElementZIndex = getElementZIndex;\nexports.POSITIONS = void 0;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nvar POSITIONS = ['top', 'right', 'bottom', 'left'];\nexports.POSITIONS = POSITIONS;\nvar relatedDimension = {\n  top: 'height',\n  right: 'width',\n  bottom: 'height',\n  left: 'width'\n};\nvar dimensionPositionAttribute = {\n  height: 'top',\n  width: 'left'\n};\nvar positionComplements = {\n  top: 'bottom',\n  right: 'left',\n  bottom: 'top',\n  left: 'right'\n}; // always resolving to top/left is taken advantage of by knowing they are the\n// minimum edges of the bounding box\n\nvar positionSubstitutes = {\n  top: 'left',\n  right: 'top',\n  bottom: 'left',\n  left: 'top'\n};\n\n/**\n * Calculates the absolute positioning (relative to document.body) to place a popover element\n *\n * @param anchor {HTMLElement} Element to anchor the popover to\n * @param popover {HTMLElement} Element containing the popover content\n * @param position {string} Position the user wants. One of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param [forcePosition] {boolean} If true, use only the provided `position` value and don't try any other position\n * @param [align] {string} Cross-axis alignment. One of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param [buffer=16] {number} Minimum distance between the popover and the bounding container\n * @param [offset=0] {number} Distance between the popover and the anchor\n * @param [allowCrossAxis=true] {boolean} Whether to allow the popover to be positioned on the cross-axis\n * @param [container] {HTMLElement} Element the popover must be constrained to fit within\n * @param [arrowConfig] {{arrowWidth: number, arrowBuffer: number}} If\n *  present, describes the size & constraints for an arrow element, and the\n *  function return value will include an `arrow` param with position details\n *\n * @returns {FindPopoverPositionResult} absolute page coordinates for the\n * popover, and the placement's relation to the anchor or undefined\n * there's no room.\n */\nfunction findPopoverPosition(_ref) {\n  var anchor = _ref.anchor,\n      popover = _ref.popover,\n      align = _ref.align,\n      position = _ref.position,\n      forcePosition = _ref.forcePosition,\n      _ref$buffer = _ref.buffer,\n      buffer = _ref$buffer === void 0 ? 16 : _ref$buffer,\n      _ref$offset = _ref.offset,\n      offset = _ref$offset === void 0 ? 0 : _ref$offset,\n      _ref$allowCrossAxis = _ref.allowCrossAxis,\n      allowCrossAxis = _ref$allowCrossAxis === void 0 ? true : _ref$allowCrossAxis,\n      container = _ref.container,\n      arrowConfig = _ref.arrowConfig,\n      returnBoundingBox = _ref.returnBoundingBox;\n  // find the screen-relative bounding boxes of the anchor, popover, and container\n  var anchorBoundingBox = getElementBoundingBox(anchor);\n  var popoverBoundingBox = getElementBoundingBox(popover); // calculate the window's bounds\n  // window.(innerWidth|innerHeight) do not account for scrollbars\n  // so prefer the clientWidth/clientHeight of the DOM if available\n\n  var documentWidth = document.documentElement.clientWidth || window.innerWidth;\n  var documentHeight = document.documentElement.clientHeight || window.innerHeight;\n  var windowBoundingBox = {\n    top: 0,\n    right: documentWidth,\n    bottom: documentHeight,\n    left: 0,\n    height: documentHeight,\n    width: documentWidth\n  }; // if no container element is given fall back to using the window viewport\n\n  var containerBoundingBox = container ? getElementBoundingBox(container) : windowBoundingBox;\n  /**\n   * `position` was specified by the function caller and is a strong hint\n   * as to the preferred location of the popover relative to the anchor.\n   * However, we strongly prefer showing all of the popover content within\n   * the window+container boundary and will iterate over the four\n   * possible sides until a perfect fit is located. If none of the locations\n   * fully contain popover, the location with the best fit is selected.\n   *\n   * This approach first checks the preferred `position`, then its opposite\n   * along the same axis, next a location on the cross-axis, and finally it\n   * tests the remaining position.\n   *\n   * e.g.\n   * if position = \"top\" the order is top, bottom, left right\n   * if position = \"right\" the order is right, left, top, bottom\n   */\n  // Try the user-desired position first.\n\n  var iterationPositions = [position]; // keep user-defined alignment in the original positions.\n\n  var iterationAlignments = [align];\n\n  if (forcePosition !== true) {\n    iterationPositions.push(positionComplements[position]); // Try the complementary position.\n\n    iterationAlignments.push(align); // keep user-defined alignment in the complementary position.\n\n    if (allowCrossAxis) {\n      iterationPositions.push(positionSubstitutes[position], // Switch to the cross axis.\n      positionComplements[positionSubstitutes[position]] // Try the complementary position on the cross axis.\n      );\n      iterationAlignments.push(undefined, undefined); // discard desired alignment on cross-axis\n    }\n  } else {\n    // position is forced, if it conflicts with the alignment then reset align to `null`\n    // e.g. original placement request for `downLeft` is moved to the `left` side, future calls\n    // will position and align `left`, and `leftLeft` is not a valid placement\n    if (position === align || align !== undefined && position === positionComplements[align]) {\n      iterationAlignments[0] = undefined;\n    }\n  }\n\n  var bestFit = undefined;\n  var bestPosition = null;\n\n  for (var idx = 0; idx < iterationPositions.length; idx++) {\n    var iterationPosition = iterationPositions[idx]; // See if we can find a position with a better fit than we've found so far.\n\n    var screenCoordinates = getPopoverScreenCoordinates({\n      position: iterationPosition,\n      align: iterationAlignments[idx],\n      anchorBoundingBox: anchorBoundingBox,\n      popoverBoundingBox: popoverBoundingBox,\n      windowBoundingBox: windowBoundingBox,\n      containerBoundingBox: containerBoundingBox,\n      offset: offset,\n      buffer: buffer,\n      arrowConfig: arrowConfig\n    });\n\n    if (bestFit === undefined || screenCoordinates.fit > bestFit) {\n      bestFit = screenCoordinates.fit;\n      bestPosition = {\n        fit: screenCoordinates.fit,\n        position: iterationPosition,\n        top: screenCoordinates.top + window.pageYOffset,\n        left: screenCoordinates.left + window.pageXOffset,\n        arrow: screenCoordinates.arrow\n      }; // If we've already found the ideal fit, use that position.\n\n      if (bestFit === 1) {\n        break;\n      }\n    } // If we haven't improved the fit, then continue on and try a new position.\n\n  }\n\n  if (bestPosition == null) {\n    throw new Error('Failed to calculate bestPosition');\n  }\n\n  if (returnBoundingBox) {\n    bestPosition.anchorBoundingBox = anchorBoundingBox;\n  }\n\n  return bestPosition;\n}\n\n/**\n * Given a target position and the popover's surrounding context, returns either an\n * object with {top, left} screen coordinates or `null` if it's not possible to show\n * content in the target position\n * @param position {string} the target position, one of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param align {string} target alignment on the cross-axis, one of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param anchorBoundingBox {Object} bounding box of the anchor element\n * @param popoverBoundingBox {Object} bounding box of the popover element\n * @param windowBoundingBox {Object} bounding box of the window\n * @param containerBoundingBox {Object} bounding box of the container\n * @param [arrowConfig] {{arrowWidth: number, arrowBuffer: number}} If present, describes the size &\n *  constraints for an arrow element, and the function return value will include an `arrow` param\n *  with position details\n * @param [offset=0] {number} Distance between the popover and the anchor\n * @param [buffer=0] {number} Minimum distance between the popover's\n *  placement and the container edge\n *\n * @returns {GetPopoverScreenCoordinatesResult}\n *  object with top/left coordinates, the popover's relative position to the anchor, and how well the\n *  popover fits in the location (0.0 -> 1.0) coordinates and the popover's relative position, if\n *  there is no room in this placement then null\n */\nfunction getPopoverScreenCoordinates(_ref2) {\n  var _popoverPlacement, _ref3;\n\n  var position = _ref2.position,\n      align = _ref2.align,\n      anchorBoundingBox = _ref2.anchorBoundingBox,\n      popoverBoundingBox = _ref2.popoverBoundingBox,\n      windowBoundingBox = _ref2.windowBoundingBox,\n      containerBoundingBox = _ref2.containerBoundingBox,\n      arrowConfig = _ref2.arrowConfig,\n      _ref2$offset = _ref2.offset,\n      offset = _ref2$offset === void 0 ? 0 : _ref2$offset,\n      _ref2$buffer = _ref2.buffer,\n      buffer = _ref2$buffer === void 0 ? 0 : _ref2$buffer;\n\n  /**\n   * The goal is to find the best way to align the popover content\n   * on the given side of the anchor element. The popover prefers\n   * centering on the anchor but can shift along the cross-axis as needed.\n   *\n   * We return the top/left coordinates that best fit the popover inside\n   * the given boundaries, and also return the `fit` value which indicates\n   * what percentage of the popover is within the bounds.\n   *\n   * e.g. finding a location when position=top\n   * the preferred location is directly over the anchor\n   *\n   *        +----------------------+\n   *        |       popover        |\n   *        +----------------------+\n   *                   v\n   *            +--------------+\n   *            |    anchor    |\n   *            +--------------+\n   *\n   * but if anchor doesn't have much (or any) room on its ride side\n   * the popover will shift to the left\n   *\n   *    +----------------------+\n   *    |       popover        |\n   *    +----------------------+\n   *                   v\n   *            +--------------+\n   *            |    anchor    |\n   *            +--------------+\n   *\n   */\n  var crossAxisFirstSide = positionSubstitutes[position]; // \"top\" -> \"left\"\n\n  var crossAxisSecondSide = positionComplements[crossAxisFirstSide]; // \"left\" -> \"right\"\n\n  var crossAxisDimension = relatedDimension[crossAxisFirstSide]; // \"left\" -> \"width\"\n\n  var _getCrossAxisPosition = getCrossAxisPosition({\n    crossAxisFirstSide: crossAxisFirstSide,\n    crossAxisSecondSide: crossAxisSecondSide,\n    crossAxisDimension: crossAxisDimension,\n    position: position,\n    align: align,\n    buffer: buffer,\n    offset: offset,\n    windowBoundingBox: windowBoundingBox,\n    containerBoundingBox: containerBoundingBox,\n    popoverBoundingBox: popoverBoundingBox,\n    anchorBoundingBox: anchorBoundingBox,\n    arrowConfig: arrowConfig\n  }),\n      crossAxisPosition = _getCrossAxisPosition.crossAxisPosition,\n      crossAxisArrowPosition = _getCrossAxisPosition.crossAxisArrowPosition;\n\n  var primaryAxisDimension = relatedDimension[position]; // \"top\" -> \"height\"\n\n  var primaryAxisPositionName = dimensionPositionAttribute[primaryAxisDimension]; // \"height\" -> \"top\"\n\n  var _getPrimaryAxisPositi = getPrimaryAxisPosition({\n    position: position,\n    offset: offset,\n    popoverBoundingBox: popoverBoundingBox,\n    anchorBoundingBox: anchorBoundingBox,\n    arrowConfig: arrowConfig\n  }),\n      primaryAxisPosition = _getPrimaryAxisPositi.primaryAxisPosition,\n      primaryAxisArrowPosition = _getPrimaryAxisPositi.primaryAxisArrowPosition;\n\n  var popoverPlacement = (_popoverPlacement = {}, _defineProperty(_popoverPlacement, crossAxisFirstSide, crossAxisPosition), _defineProperty(_popoverPlacement, primaryAxisPositionName, primaryAxisPosition), _popoverPlacement); // calculate the fit of the popover in this location\n  // fit is in range 0.0 -> 1.0 and is the percentage of the popover which is visible in this location\n\n  var combinedBoundingBox = intersectBoundingBoxes(windowBoundingBox, containerBoundingBox); // shrink the visible bounding box by `buffer`\n  // to compute a fit value\n\n  combinedBoundingBox.top += buffer;\n  combinedBoundingBox.right -= buffer;\n  combinedBoundingBox.bottom -= buffer;\n  combinedBoundingBox.left += buffer;\n  var fit = getVisibleFit({\n    top: popoverPlacement.top,\n    right: popoverPlacement.left + popoverBoundingBox.width,\n    bottom: popoverPlacement.top + popoverBoundingBox.height,\n    left: popoverPlacement.left,\n    width: popoverBoundingBox.width,\n    height: popoverBoundingBox.height\n  }, combinedBoundingBox);\n  var arrow = arrowConfig ? (_ref3 = {}, _defineProperty(_ref3, crossAxisFirstSide, crossAxisArrowPosition - popoverPlacement[crossAxisFirstSide]), _defineProperty(_ref3, primaryAxisPositionName, primaryAxisArrowPosition), _ref3) : undefined;\n  return {\n    fit: fit,\n    top: popoverPlacement.top,\n    left: popoverPlacement.left,\n    arrow: arrow ? {\n      left: arrow.left,\n      top: arrow.top\n    } : undefined\n  };\n}\n\nfunction getCrossAxisPosition(_ref4) {\n  var crossAxisFirstSide = _ref4.crossAxisFirstSide,\n      crossAxisSecondSide = _ref4.crossAxisSecondSide,\n      crossAxisDimension = _ref4.crossAxisDimension,\n      position = _ref4.position,\n      align = _ref4.align,\n      buffer = _ref4.buffer,\n      offset = _ref4.offset,\n      windowBoundingBox = _ref4.windowBoundingBox,\n      containerBoundingBox = _ref4.containerBoundingBox,\n      popoverBoundingBox = _ref4.popoverBoundingBox,\n      anchorBoundingBox = _ref4.anchorBoundingBox,\n      arrowConfig = _ref4.arrowConfig;\n  // how much of the popover overflows past either side of the anchor if its centered\n  var popoverSizeOnCrossAxis = popoverBoundingBox[crossAxisDimension];\n  var anchorSizeOnCrossAxis = anchorBoundingBox[crossAxisDimension];\n  var anchorHalfSize = anchorSizeOnCrossAxis / 2; // the popover's original position on the cross-axis is determined by:\n\n  var crossAxisPositionOriginal = anchorBoundingBox[crossAxisFirstSide] + // where the anchor is located\n  anchorHalfSize - // plus half anchor dimension\n  popoverSizeOnCrossAxis / 2; // less half the popover dimension\n  // To fit the content within both the window and container,\n  // compute the smaller of the two spaces along each edge\n\n  var combinedBoundingBox = intersectBoundingBoxes(windowBoundingBox, containerBoundingBox);\n  var availableSpace = getAvailableSpace(anchorBoundingBox, combinedBoundingBox, buffer, offset, position);\n  var minimumSpace = arrowConfig ? arrowConfig.arrowBuffer : 0;\n  var contentOverflowSize = (popoverSizeOnCrossAxis - anchorSizeOnCrossAxis) / 2;\n  var alignAmount = 0;\n  var alignDirection = 1;\n  var amountOfShiftNeeded = 0;\n  var shiftDirection = 1;\n\n  if (align != null) {\n    // no alignment, find how much the container boundary requires the content to shift\n    alignDirection = align === 'top' || align === 'left' ? 1 : -1;\n    alignAmount = contentOverflowSize;\n    var alignedOverflowAmount = contentOverflowSize + alignAmount;\n    var needsShift = alignedOverflowAmount > availableSpace[positionComplements[align]];\n    amountOfShiftNeeded = needsShift ? alignedOverflowAmount - availableSpace[positionComplements[align]] : 0;\n    shiftDirection = -1 * alignDirection;\n  } else {\n    // shifting the popover to one side may yield a better fit\n    var spaceAvailableOnFirstSide = availableSpace[crossAxisFirstSide];\n    var spaceAvailableOnSecondSide = availableSpace[crossAxisSecondSide];\n    var isShiftTowardFirstSide = spaceAvailableOnFirstSide > spaceAvailableOnSecondSide;\n    shiftDirection = isShiftTowardFirstSide ? -1 : 1; // determine which direction has more room and the popover should shift to\n\n    var leastAvailableSpace = Math.min(spaceAvailableOnFirstSide, spaceAvailableOnSecondSide);\n\n    var _needsShift = contentOverflowSize > leastAvailableSpace;\n\n    amountOfShiftNeeded = _needsShift ? contentOverflowSize - leastAvailableSpace : 0;\n  } // shift over the popover if necessary\n\n\n  var shiftAmount = amountOfShiftNeeded * shiftDirection;\n  var crossAxisPosition = crossAxisPositionOriginal + shiftAmount + alignAmount * alignDirection; // if an `arrowConfig` is specified, find where to position the arrow\n\n  var crossAxisArrowPosition;\n\n  if (arrowConfig) {\n    var arrowWidth = arrowConfig.arrowWidth;\n    crossAxisArrowPosition = anchorBoundingBox[crossAxisFirstSide] + anchorHalfSize - arrowWidth / 2; // make sure there's enough buffer around the arrow\n    // by calculating how how much the arrow would need to move\n    // but instead of moving the arrow, shift the popover content\n\n    if (crossAxisArrowPosition < crossAxisPosition + minimumSpace) {\n      // arrow is too close to the minimum side\n      var difference = crossAxisPosition + minimumSpace - crossAxisArrowPosition;\n      crossAxisPosition -= difference;\n    } else if (crossAxisArrowPosition + minimumSpace + arrowWidth > crossAxisPosition + popoverSizeOnCrossAxis) {\n      // arrow is too close to the maximum side\n      var edge = crossAxisPosition + popoverSizeOnCrossAxis;\n\n      var _difference = crossAxisArrowPosition - (edge - minimumSpace - arrowWidth);\n\n      crossAxisPosition += _difference;\n    }\n  }\n\n  return {\n    crossAxisPosition: crossAxisPosition,\n    crossAxisArrowPosition: crossAxisArrowPosition\n  };\n}\n\nfunction getPrimaryAxisPosition(_ref5) {\n  var position = _ref5.position,\n      offset = _ref5.offset,\n      popoverBoundingBox = _ref5.popoverBoundingBox,\n      anchorBoundingBox = _ref5.anchorBoundingBox,\n      arrowConfig = _ref5.arrowConfig;\n  // if positioning to the top or left, the target position decreases\n  // from the anchor's top or left, otherwise the position adds to the anchor's\n  var isOffsetDecreasing = position === 'top' || position === 'left';\n  var primaryAxisDimension = relatedDimension[position]; // \"top\" -> \"height\"\n\n  var popoverSizeOnPrimaryAxis = popoverBoundingBox[primaryAxisDimension]; // start at the top or left edge of the anchor element\n\n  var primaryAxisPositionName = dimensionPositionAttribute[primaryAxisDimension]; // \"height\" -> \"top\"\n\n  var anchorEdgeOrigin = anchorBoundingBox[primaryAxisPositionName]; // find the popover position on the primary axis\n\n  var anchorSizeOnPrimaryAxis = anchorBoundingBox[primaryAxisDimension];\n  var primaryAxisOffset = isOffsetDecreasing ? popoverSizeOnPrimaryAxis : anchorSizeOnPrimaryAxis;\n  var contentOffset = (offset + primaryAxisOffset) * (isOffsetDecreasing ? -1 : 1);\n  var primaryAxisPosition = anchorEdgeOrigin + contentOffset;\n  var primaryAxisArrowPosition;\n\n  if (arrowConfig) {\n    primaryAxisArrowPosition = isOffsetDecreasing ? popoverSizeOnPrimaryAxis : 0;\n  }\n\n  return {\n    primaryAxisPosition: primaryAxisPosition,\n    primaryAxisArrowPosition: primaryAxisArrowPosition\n  };\n}\n/**\n * Finds the client pixel coordinate of each edge for the element's bounding box,\n * and the bounding box's width & height\n *\n * @param {HTMLElement} element\n * @returns {{top: number, right: number, bottom: number, left: number, height: number, width: number}}\n */\n\n\nfunction getElementBoundingBox(element) {\n  var rect = element.getBoundingClientRect();\n  return {\n    top: rect.top,\n    right: rect.right,\n    bottom: rect.bottom,\n    left: rect.left,\n    height: rect.height,\n    width: rect.width\n  };\n}\n/**\n * Calculates the available content space between anchor and container\n *\n * @param {Object} anchorBoundingBox Client bounding box of the anchor element\n * @param {Object} containerBoundingBox Client bounding box of the container element\n * @param {number} buffer Minimum distance between the popover and the bounding container\n * @param {number} offset Distance between the popover and the anchor\n * @param {string} offsetSide Side the offset needs to be applied to, one\n *  of [\"top\", \"right\", \"bottom\", \"left\"]\n * @returns {{top: number, right: number, bottom: number, left: number}}\n */\n\n\nfunction getAvailableSpace(anchorBoundingBox, containerBoundingBox, buffer, offset, offsetSide) {\n  return {\n    top: anchorBoundingBox.top - containerBoundingBox.top - buffer - (offsetSide === 'top' ? offset : 0),\n    right: containerBoundingBox.right - anchorBoundingBox.right - buffer - (offsetSide === 'right' ? offset : 0),\n    bottom: containerBoundingBox.bottom - anchorBoundingBox.bottom - buffer - (offsetSide === 'bottom' ? offset : 0),\n    left: anchorBoundingBox.left - containerBoundingBox.left - buffer - (offsetSide === 'left' ? offset : 0)\n  };\n}\n/**\n * Computes the fit (overlap) of the content within the container, fit is in range 0.0 => 1.0\n * @param contentBoundingBox bounding box of content to calculate fit for\n * @param containerBoundingBox bounding box of container\n * @returns {number}\n */\n\n\nfunction getVisibleFit(contentBoundingBox, containerBoundingBox) {\n  var intersection = intersectBoundingBoxes(contentBoundingBox, containerBoundingBox);\n\n  if (intersection.left > intersection.right || intersection.top > intersection.top) {\n    // there is no intersection, the boxes are completely separated on at least one axis\n    return 0;\n  }\n\n  var intersectionArea = (intersection.right - intersection.left) * (intersection.bottom - intersection.top);\n  var contentArea = (contentBoundingBox.right - contentBoundingBox.left) * (contentBoundingBox.bottom - contentBoundingBox.top);\n  return intersectionArea / contentArea;\n}\n/**\n * Calculates the intersection space between two bounding boxes\n *\n * @param firstBox\n * @param secondBox\n * @returns {EuiClientRect}\n */\n\n\nfunction intersectBoundingBoxes(firstBox, secondBox) {\n  var top = Math.max(firstBox.top, secondBox.top);\n  var right = Math.min(firstBox.right, secondBox.right);\n  var bottom = Math.min(firstBox.bottom, secondBox.bottom);\n  var left = Math.max(firstBox.left, secondBox.left);\n  var height = Math.max(bottom - top, 0);\n  var width = Math.max(right - left, 0);\n  return {\n    top: top,\n    right: right,\n    bottom: bottom,\n    left: left,\n    height: height,\n    width: width\n  };\n}\n/**\n * Returns the top-most defined z-index in the element's ancestor hierarchy\n * relative to the `target` element; if no z-index is defined, returns 0\n * @param element {HTMLElement}\n * @param cousin {HTMLElement}\n * @returns {number}\n */\n\n\nfunction getElementZIndex(element, cousin) {\n  /**\n   * finding the z-index of `element` is not the full story\n   * its the CSS stacking context that is important\n   * take this DOM for example:\n   * body\n   *   section[z-index: 1000]\n   *     p[z-index: 500]\n   *       button\n   *   div\n   *\n   * what z-index does the `div` need to display next to `button`?\n   * the `div` and `section` are where the stacking context splits\n   * so `div` needs to copy `section`'s z-index in order to\n   * appear next to / over `button`\n   *\n   * calculate this by starting at `button` and finding its offsetParents\n   * then walk the parents from top -> down until the stacking context\n   * split is found, or if there is no split then a specific z-index is unimportant\n   */\n  // build the array of the element + its offset parents\n  var nodesToInspect = [];\n\n  while (true) {\n    nodesToInspect.push(element); // AFAICT this is a valid cast - the libdefs appear wrong\n\n    element = element.offsetParent; // stop if there is no parent\n\n    if (element == null) {\n      break;\n    } // stop if the parent contains the related element\n    // as this is the z-index ancestor\n\n\n    if (element.contains(cousin)) {\n      break;\n    }\n  } // reverse the nodes to walk from top -> element\n\n\n  nodesToInspect.reverse();\n\n  for (var _i = 0, _nodesToInspect = nodesToInspect; _i < _nodesToInspect.length; _i++) {\n    var node = _nodesToInspect[_i];\n    // get this node's z-index css value\n    var zIndex = window.document.defaultView.getComputedStyle(node).getPropertyValue('z-index'); // if the z-index is not a number (e.g. \"auto\") return null, else the value\n\n    var parsedZIndex = parseInt(zIndex, 10);\n\n    if (!isNaN(parsedZIndex)) {\n      return parsedZIndex;\n    }\n  }\n\n  return 0;\n}"]},"metadata":{},"sourceType":"script"}