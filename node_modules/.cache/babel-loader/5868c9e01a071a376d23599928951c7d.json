{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\nimport { defaultSyntax } from './default_syntax';\nimport { executeAst } from './execute_ast';\nimport { isNil, isString } from '../../../services/predicate';\nimport { astToEsQueryDsl } from './ast_to_es_query_dsl';\nimport { astToEsQueryString } from './ast_to_es_query_string';\nimport { AST, Operator } from './ast';\n/**\n * This is the consumer interface for the query - it's effectively a wrapper construct around\n * the AST and some of its related utility functions (e.g. parsing, text representation, executing, etc...)\n * It is immutable - all mutating operations return a new (mutated) query instance.\n */\n\nexport var Query = /*#__PURE__*/function () {\n  _createClass(Query, null, [{\n    key: \"parse\",\n    value: function parse(text, options) {\n      var syntax = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultSyntax;\n      return new Query(syntax.parse(text, options), syntax, text);\n    }\n  }, {\n    key: \"isMust\",\n    value: function isMust(clause) {\n      return AST.Match.isMustClause(clause);\n    }\n  }, {\n    key: \"isTerm\",\n    value: function isTerm(clause) {\n      return AST.Term.isInstance(clause);\n    }\n  }, {\n    key: \"isIs\",\n    value: function isIs(clause) {\n      return AST.Is.isInstance(clause);\n    }\n  }, {\n    key: \"isField\",\n    value: function isField(clause) {\n      return AST.Field.isInstance(clause);\n    } // This ought to be `private`, but Kibana has some customizations that rely on access to this field\n\n  }]);\n\n  function Query(ast) {\n    var syntax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultSyntax;\n    var text = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, Query);\n\n    _defineProperty(this, \"ast\", void 0);\n\n    _defineProperty(this, \"text\", void 0);\n\n    _defineProperty(this, \"syntax\", void 0);\n\n    this.ast = ast;\n    this.text = text || syntax.print(ast);\n    this.syntax = syntax;\n  }\n\n  _createClass(Query, [{\n    key: \"hasSimpleFieldClause\",\n    value: function hasSimpleFieldClause(field, value) {\n      return this.ast.hasSimpleFieldClause(field, value);\n    }\n  }, {\n    key: \"getSimpleFieldClause\",\n    value: function getSimpleFieldClause(field, value) {\n      return this.ast.getSimpleFieldClause(field, value);\n    }\n  }, {\n    key: \"removeSimpleFieldClauses\",\n    value: function removeSimpleFieldClauses(field) {\n      var ast = this.ast.removeSimpleFieldClauses(field);\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"addSimpleFieldValue\",\n    value: function addSimpleFieldValue(field, value) {\n      var must = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var operator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Operator.EQ;\n      var ast = this.ast.addSimpleFieldValue(field, value, must, operator);\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"removeSimpleFieldValue\",\n    value: function removeSimpleFieldValue(field, value) {\n      var ast = this.ast.removeSimpleFieldValue(field, value);\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"hasOrFieldClause\",\n    value: function hasOrFieldClause(field, value) {\n      return this.ast.hasOrFieldClause(field, value);\n    }\n  }, {\n    key: \"getOrFieldClause\",\n    value: function getOrFieldClause(field, value) {\n      return this.ast.getOrFieldClause(field, value);\n    }\n  }, {\n    key: \"addOrFieldValue\",\n    value: function addOrFieldValue(field, value) {\n      var must = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var ast = this.ast.addOrFieldValue(field, value, must);\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"removeOrFieldValue\",\n    value: function removeOrFieldValue(field, value) {\n      var ast = this.ast.removeOrFieldValue(field, value);\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"removeOrFieldClauses\",\n    value: function removeOrFieldClauses(field) {\n      var ast = this.ast.removeOrFieldClauses(field);\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"hasIsClause\",\n    value: function hasIsClause(flag) {\n      return !isNil(this.ast.getIsClause(flag));\n    }\n  }, {\n    key: \"getIsClause\",\n    value: function getIsClause(flag) {\n      return this.ast.getIsClause(flag);\n    }\n  }, {\n    key: \"addMustIsClause\",\n    value: function addMustIsClause(flag) {\n      var ast = this.ast.addClause(AST.Is.must(flag));\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"addMustNotIsClause\",\n    value: function addMustNotIsClause(flag) {\n      var ast = this.ast.addClause(AST.Is.mustNot(flag));\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"removeIsClause\",\n    value: function removeIsClause(flag) {\n      var ast = this.ast.removeIsClause(flag);\n      return new Query(ast, this.syntax);\n    }\n    /**\n     * Executes this query over the given iterable item and returns\n     * an new array of all items that matched this query. Options:\n     *\n     * defaultFields: string[]\n     *\n     *    An array of field names to match the default clauses against. When not specified, the query\n     *    will pick up all the string fields of each record and try to match against those.\n     *\n     * isClauseMatcher?: (record: any, flag: string, applied: boolean, explain?: []) => boolean\n     *\n     *    By default the 'is' clauses will try to match against boolean fields - where the flag of the clause\n     *    indicates the field name. You can change this behaviour by providing this matcher function for the\n     *    is clause. For example, if the object has a `tags` field, one can create a matcher that checks if\n     *    an object has a specific tag (e.g. \"is:marketing\", \"is:kitchen\", etc..)\n     *\n     * explain?: boolean\n     *\n     *    When set to `true`, each item in the returns array will have an `__explain` field that will hold\n     *    information about why the objects matched the query (default to `false`, mainly/only useful for\n     *    debugging)\n     */\n\n  }], [{\n    key: \"execute\",\n    value: function execute(query, items) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var q = isString(query) ? Query.parse(query) : query;\n      return executeAst(q.ast, items, options);\n    }\n    /**\n     * Builds and returns an Elasticsearch query out this query. Options:\n     *\n     * defaultFields?: string[]\n     *\n     *    An array of field names to match the default clauses against. When not specified, the query\n     *    will pick up all the string fields of each record and try to match against those.\n     *\n     * isToQuery?: (flag: string, on: boolean) => Object (elasticsearch query object)\n     *\n     *    By default, \"is\" clauses will be translated to a term query where the flag is the field\n     *    and the \"on\" value will be the value of the field. This function lets you change this default\n     *    translation and provide your own custom one.\n     *\n     * termValuesToQuery?: (values: string[]) => Object (elasticsearch query object)\n     *\n     *    By default, \"term\" clauses will be translated to a \"simple_query_string\" query where all\n     *    the values serve as terms in the query string. This function lets you change this default\n     *    translation and provide your own custom one.\n     *\n     * fieldValuesToAndQuery?: (field: string, values: string[]) => Object (elasticsearch query object)\n     *\n     *    By default, \"field\" clauses will be translated to a match query where all the values serve as\n     *    terms in the query(the operator is AND). This function lets you change this default translation\n     *    and provide your own custom one.\n     */\n\n  }, {\n    key: \"toESQuery\",\n    value: function toESQuery(query) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var q = isString(query) ? Query.parse(query) : query;\n      return astToEsQueryDsl(q.ast, options);\n    }\n  }, {\n    key: \"toESQueryString\",\n    value: function toESQueryString(query) {\n      var q = isString(query) ? Query.parse(query) : query;\n      return astToEsQueryString(q.ast);\n    }\n  }]);\n\n  return Query;\n}();\n\n_defineProperty(Query, \"MATCH_ALL\", Query.parse(''));","map":{"version":3,"sources":["/home/nadaanbaalak/greendeck/client/node_modules/@elastic/eui/es/components/search_bar/query/query.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","_defineProperty","obj","value","defaultSyntax","executeAst","isNil","isString","astToEsQueryDsl","astToEsQueryString","AST","Operator","Query","parse","text","options","syntax","arguments","undefined","isMust","clause","Match","isMustClause","isTerm","Term","isInstance","isIs","Is","isField","Field","ast","print","hasSimpleFieldClause","field","getSimpleFieldClause","removeSimpleFieldClauses","addSimpleFieldValue","must","operator","EQ","removeSimpleFieldValue","hasOrFieldClause","getOrFieldClause","addOrFieldValue","removeOrFieldValue","removeOrFieldClauses","hasIsClause","flag","getIsClause","addMustIsClause","addClause","addMustNotIsClause","mustNot","removeIsClause","execute","query","items","q","toESQuery","toESQueryString"],"mappings":"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","sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { defaultSyntax } from './default_syntax';\nimport { executeAst } from './execute_ast';\nimport { isNil, isString } from '../../../services/predicate';\nimport { astToEsQueryDsl } from './ast_to_es_query_dsl';\nimport { astToEsQueryString } from './ast_to_es_query_string';\nimport { AST, Operator } from './ast';\n/**\n * This is the consumer interface for the query - it's effectively a wrapper construct around\n * the AST and some of its related utility functions (e.g. parsing, text representation, executing, etc...)\n * It is immutable - all mutating operations return a new (mutated) query instance.\n */\n\nexport var Query =\n/*#__PURE__*/\nfunction () {\n  _createClass(Query, null, [{\n    key: \"parse\",\n    value: function parse(text, options) {\n      var syntax = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultSyntax;\n      return new Query(syntax.parse(text, options), syntax, text);\n    }\n  }, {\n    key: \"isMust\",\n    value: function isMust(clause) {\n      return AST.Match.isMustClause(clause);\n    }\n  }, {\n    key: \"isTerm\",\n    value: function isTerm(clause) {\n      return AST.Term.isInstance(clause);\n    }\n  }, {\n    key: \"isIs\",\n    value: function isIs(clause) {\n      return AST.Is.isInstance(clause);\n    }\n  }, {\n    key: \"isField\",\n    value: function isField(clause) {\n      return AST.Field.isInstance(clause);\n    } // This ought to be `private`, but Kibana has some customizations that rely on access to this field\n\n  }]);\n\n  function Query(ast) {\n    var syntax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultSyntax;\n    var text = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, Query);\n\n    _defineProperty(this, \"ast\", void 0);\n\n    _defineProperty(this, \"text\", void 0);\n\n    _defineProperty(this, \"syntax\", void 0);\n\n    this.ast = ast;\n    this.text = text || syntax.print(ast);\n    this.syntax = syntax;\n  }\n\n  _createClass(Query, [{\n    key: \"hasSimpleFieldClause\",\n    value: function hasSimpleFieldClause(field, value) {\n      return this.ast.hasSimpleFieldClause(field, value);\n    }\n  }, {\n    key: \"getSimpleFieldClause\",\n    value: function getSimpleFieldClause(field, value) {\n      return this.ast.getSimpleFieldClause(field, value);\n    }\n  }, {\n    key: \"removeSimpleFieldClauses\",\n    value: function removeSimpleFieldClauses(field) {\n      var ast = this.ast.removeSimpleFieldClauses(field);\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"addSimpleFieldValue\",\n    value: function addSimpleFieldValue(field, value) {\n      var must = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var operator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Operator.EQ;\n      var ast = this.ast.addSimpleFieldValue(field, value, must, operator);\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"removeSimpleFieldValue\",\n    value: function removeSimpleFieldValue(field, value) {\n      var ast = this.ast.removeSimpleFieldValue(field, value);\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"hasOrFieldClause\",\n    value: function hasOrFieldClause(field, value) {\n      return this.ast.hasOrFieldClause(field, value);\n    }\n  }, {\n    key: \"getOrFieldClause\",\n    value: function getOrFieldClause(field, value) {\n      return this.ast.getOrFieldClause(field, value);\n    }\n  }, {\n    key: \"addOrFieldValue\",\n    value: function addOrFieldValue(field, value) {\n      var must = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var ast = this.ast.addOrFieldValue(field, value, must);\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"removeOrFieldValue\",\n    value: function removeOrFieldValue(field, value) {\n      var ast = this.ast.removeOrFieldValue(field, value);\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"removeOrFieldClauses\",\n    value: function removeOrFieldClauses(field) {\n      var ast = this.ast.removeOrFieldClauses(field);\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"hasIsClause\",\n    value: function hasIsClause(flag) {\n      return !isNil(this.ast.getIsClause(flag));\n    }\n  }, {\n    key: \"getIsClause\",\n    value: function getIsClause(flag) {\n      return this.ast.getIsClause(flag);\n    }\n  }, {\n    key: \"addMustIsClause\",\n    value: function addMustIsClause(flag) {\n      var ast = this.ast.addClause(AST.Is.must(flag));\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"addMustNotIsClause\",\n    value: function addMustNotIsClause(flag) {\n      var ast = this.ast.addClause(AST.Is.mustNot(flag));\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"removeIsClause\",\n    value: function removeIsClause(flag) {\n      var ast = this.ast.removeIsClause(flag);\n      return new Query(ast, this.syntax);\n    }\n    /**\n     * Executes this query over the given iterable item and returns\n     * an new array of all items that matched this query. Options:\n     *\n     * defaultFields: string[]\n     *\n     *    An array of field names to match the default clauses against. When not specified, the query\n     *    will pick up all the string fields of each record and try to match against those.\n     *\n     * isClauseMatcher?: (record: any, flag: string, applied: boolean, explain?: []) => boolean\n     *\n     *    By default the 'is' clauses will try to match against boolean fields - where the flag of the clause\n     *    indicates the field name. You can change this behaviour by providing this matcher function for the\n     *    is clause. For example, if the object has a `tags` field, one can create a matcher that checks if\n     *    an object has a specific tag (e.g. \"is:marketing\", \"is:kitchen\", etc..)\n     *\n     * explain?: boolean\n     *\n     *    When set to `true`, each item in the returns array will have an `__explain` field that will hold\n     *    information about why the objects matched the query (default to `false`, mainly/only useful for\n     *    debugging)\n     */\n\n  }], [{\n    key: \"execute\",\n    value: function execute(query, items) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var q = isString(query) ? Query.parse(query) : query;\n      return executeAst(q.ast, items, options);\n    }\n    /**\n     * Builds and returns an Elasticsearch query out this query. Options:\n     *\n     * defaultFields?: string[]\n     *\n     *    An array of field names to match the default clauses against. When not specified, the query\n     *    will pick up all the string fields of each record and try to match against those.\n     *\n     * isToQuery?: (flag: string, on: boolean) => Object (elasticsearch query object)\n     *\n     *    By default, \"is\" clauses will be translated to a term query where the flag is the field\n     *    and the \"on\" value will be the value of the field. This function lets you change this default\n     *    translation and provide your own custom one.\n     *\n     * termValuesToQuery?: (values: string[]) => Object (elasticsearch query object)\n     *\n     *    By default, \"term\" clauses will be translated to a \"simple_query_string\" query where all\n     *    the values serve as terms in the query string. This function lets you change this default\n     *    translation and provide your own custom one.\n     *\n     * fieldValuesToAndQuery?: (field: string, values: string[]) => Object (elasticsearch query object)\n     *\n     *    By default, \"field\" clauses will be translated to a match query where all the values serve as\n     *    terms in the query(the operator is AND). This function lets you change this default translation\n     *    and provide your own custom one.\n     */\n\n  }, {\n    key: \"toESQuery\",\n    value: function toESQuery(query) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var q = isString(query) ? Query.parse(query) : query;\n      return astToEsQueryDsl(q.ast, options);\n    }\n  }, {\n    key: \"toESQueryString\",\n    value: function toESQueryString(query) {\n      var q = isString(query) ? Query.parse(query) : query;\n      return astToEsQueryString(q.ast);\n    }\n  }]);\n\n  return Query;\n}();\n\n_defineProperty(Query, \"MATCH_ALL\", Query.parse(''));"]},"metadata":{},"sourceType":"module"}