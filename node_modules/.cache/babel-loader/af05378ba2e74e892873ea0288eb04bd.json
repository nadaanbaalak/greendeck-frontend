{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\nimport { cloneElement } from 'react';\nimport { isBoolean, isString, isNumber } from '../../services/predicate/lodash_predicates';\nimport { isElement } from 'react-is';\n\nfunction isPrimitive(value) {\n  return isBoolean(value) || isString(value) || isNumber(value);\n}\n\nfunction hasPropName(child) {\n  return child ? _typeof(child) === 'object' && child.hasOwnProperty('propName') : false;\n}\n/**\n * Replaces placeholder values in `input` with their matching value in `values`\n * e.g. input:'Hello, {name}' will replace `{name}` with `values[name]`\n * @param {string} input\n * @param {RenderableValues} values\n * @param {Function} i18nMappingFunc\n * @returns {string | React.ReactChild[]}\n */\n\n\nexport function processStringToChildren(input, values, i18nMappingFunc) {\n  var children = [];\n  var child;\n\n  function appendCharToChild(char) {\n    if (child === undefined) {\n      // starting a new string literal\n      child = char;\n    } else if (typeof child === 'string') {\n      // existing string literal\n      child = child + char;\n    } else if (hasPropName(child)) {\n      // adding to the propName of a values lookup\n      child.propName = child.propName + char;\n    }\n  }\n\n  function appendValueToChildren(value) {\n    if (value === undefined) {\n      return;\n    } else if (isElement(value)) {\n      // an array with any ReactElements will be kept as an array\n      // so they need to be assigned a key\n      children.push(cloneElement(value, {\n        key: children.length\n      }));\n    } else if (hasPropName(value)) {// this won't be called, propName children are converted to a ReactChild before calling this\n    } else {\n      // everything else can go straight in\n      if (i18nMappingFunc !== undefined && typeof value === 'string') {\n        value = i18nMappingFunc(value);\n      }\n\n      children.push(value);\n    }\n  } // if we don't encounter a non-primitive\n  // then `children` can be concatenated together at the end\n\n\n  var encounteredNonPrimitive = false; // tslint:disable-next-line:prefer-for-of\n\n  for (var i = 0; i < input.length; i++) {\n    var char = input[i];\n\n    if (char === '\\\\') {\n      // peek at the next character to know if this is an escape\n      var nextChar = input[i + 1];\n      var charToAdd = char; // if this isn't an escape sequence then we will add the backslash\n\n      if (nextChar === '{' || nextChar === '}') {\n        // escaping a brace\n        i += 1; // advance passed the brace\n\n        charToAdd = input[i];\n      }\n\n      appendCharToChild(charToAdd);\n    } else if (char === '{') {\n      appendValueToChildren(child);\n      child = {\n        propName: ''\n      };\n    } else if (char === '}') {\n      var propName = child.propName;\n\n      if (!values.hasOwnProperty(propName)) {\n        throw new Error(\"Key \\\"\".concat(propName, \"\\\" not found in \").concat(JSON.stringify(values, null, 2)));\n      }\n\n      var propValue = values[propName];\n      encounteredNonPrimitive = encounteredNonPrimitive || !isPrimitive(propValue);\n      appendValueToChildren(propValue);\n      child = undefined;\n    } else {\n      appendCharToChild(char);\n    }\n  } // include any remaining child value\n\n\n  appendValueToChildren(child);\n  return encounteredNonPrimitive ? children : children.join('');\n}","map":{"version":3,"sources":["/home/nadaanbaalak/greendeck/client/node_modules/@elastic/eui/es/components/i18n/i18n_util.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","cloneElement","isBoolean","isString","isNumber","isElement","isPrimitive","value","hasPropName","child","hasOwnProperty","processStringToChildren","input","values","i18nMappingFunc","children","appendCharToChild","char","undefined","propName","appendValueToChildren","push","key","length","encounteredNonPrimitive","i","nextChar","charToAdd","Error","concat","JSON","stringify","propValue","join"],"mappings":"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","sourcesContent":["function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { cloneElement } from 'react';\nimport { isBoolean, isString, isNumber } from '../../services/predicate/lodash_predicates';\nimport { isElement } from 'react-is';\n\nfunction isPrimitive(value) {\n  return isBoolean(value) || isString(value) || isNumber(value);\n}\n\nfunction hasPropName(child) {\n  return child ? _typeof(child) === 'object' && child.hasOwnProperty('propName') : false;\n}\n/**\n * Replaces placeholder values in `input` with their matching value in `values`\n * e.g. input:'Hello, {name}' will replace `{name}` with `values[name]`\n * @param {string} input\n * @param {RenderableValues} values\n * @param {Function} i18nMappingFunc\n * @returns {string | React.ReactChild[]}\n */\n\n\nexport function processStringToChildren(input, values, i18nMappingFunc) {\n  var children = [];\n  var child;\n\n  function appendCharToChild(char) {\n    if (child === undefined) {\n      // starting a new string literal\n      child = char;\n    } else if (typeof child === 'string') {\n      // existing string literal\n      child = child + char;\n    } else if (hasPropName(child)) {\n      // adding to the propName of a values lookup\n      child.propName = child.propName + char;\n    }\n  }\n\n  function appendValueToChildren(value) {\n    if (value === undefined) {\n      return;\n    } else if (isElement(value)) {\n      // an array with any ReactElements will be kept as an array\n      // so they need to be assigned a key\n      children.push(cloneElement(value, {\n        key: children.length\n      }));\n    } else if (hasPropName(value)) {// this won't be called, propName children are converted to a ReactChild before calling this\n    } else {\n      // everything else can go straight in\n      if (i18nMappingFunc !== undefined && typeof value === 'string') {\n        value = i18nMappingFunc(value);\n      }\n\n      children.push(value);\n    }\n  } // if we don't encounter a non-primitive\n  // then `children` can be concatenated together at the end\n\n\n  var encounteredNonPrimitive = false; // tslint:disable-next-line:prefer-for-of\n\n  for (var i = 0; i < input.length; i++) {\n    var char = input[i];\n\n    if (char === '\\\\') {\n      // peek at the next character to know if this is an escape\n      var nextChar = input[i + 1];\n      var charToAdd = char; // if this isn't an escape sequence then we will add the backslash\n\n      if (nextChar === '{' || nextChar === '}') {\n        // escaping a brace\n        i += 1; // advance passed the brace\n\n        charToAdd = input[i];\n      }\n\n      appendCharToChild(charToAdd);\n    } else if (char === '{') {\n      appendValueToChildren(child);\n      child = {\n        propName: ''\n      };\n    } else if (char === '}') {\n      var propName = child.propName;\n\n      if (!values.hasOwnProperty(propName)) {\n        throw new Error(\"Key \\\"\".concat(propName, \"\\\" not found in \").concat(JSON.stringify(values, null, 2)));\n      }\n\n      var propValue = values[propName];\n      encounteredNonPrimitive = encounteredNonPrimitive || !isPrimitive(propValue);\n      appendValueToChildren(propValue);\n      child = undefined;\n    } else {\n      appendCharToChild(char);\n    }\n  } // include any remaining child value\n\n\n  appendValueToChildren(child);\n  return encounteredNonPrimitive ? children : children.join('');\n}"]},"metadata":{},"sourceType":"module"}