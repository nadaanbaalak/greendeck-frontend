{"ast":null,"code":"import _extends from 'babel-runtime/helpers/extends';\nimport _Object$getPrototypeOf from 'babel-runtime/core-js/object/get-prototype-of';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _createClass from 'babel-runtime/helpers/createClass';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\nimport clsx from 'clsx';\nimport PropTypes from 'prop-types';\nimport * as React from 'react';\nimport { polyfill } from 'react-lifecycles-compat';\nimport createCallbackMemoizer from '../utils/createCallbackMemoizer';\nimport getScrollbarSize from 'dom-helpers/scrollbarSize'; // @TODO Merge Collection and CollectionView\n\n/**\n * Specifies the number of milliseconds during which to disable pointer events while a scroll is in progress.\n * This improves performance and makes scrolling smoother.\n */\n\nvar IS_SCROLLING_TIMEOUT = 150;\n/**\n * Controls whether the Grid updates the DOM element's scrollLeft/scrollTop based on the current state or just observes it.\n * This prevents Grid from interrupting mouse-wheel animations (see issue #2).\n */\n\nvar SCROLL_POSITION_CHANGE_REASONS = {\n  OBSERVED: 'observed',\n  REQUESTED: 'requested'\n};\n/**\n * Monitors changes in properties (eg. cellCount) and state (eg. scroll offsets) to determine when rendering needs to occur.\n * This component does not render any visible content itself; it defers to the specified :cellLayoutManager.\n */\n\nvar CollectionView = function (_React$PureComponent) {\n  _inherits(CollectionView, _React$PureComponent); // Invokes callbacks only when their values have changed.\n\n\n  function CollectionView() {\n    var _ref;\n\n    _classCallCheck(this, CollectionView);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    } // If this component is being rendered server-side, getScrollbarSize() will return undefined.\n    // We handle this case in componentDidMount()\n\n\n    var _this = _possibleConstructorReturn(this, (_ref = CollectionView.__proto__ || _Object$getPrototypeOf(CollectionView)).call.apply(_ref, [this].concat(args)));\n\n    _this.state = {\n      isScrolling: false,\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n    _this._calculateSizeAndPositionDataOnNextUpdate = false;\n    _this._onSectionRenderedMemoizer = createCallbackMemoizer();\n    _this._onScrollMemoizer = createCallbackMemoizer(false);\n\n    _this._invokeOnSectionRenderedHelper = function () {\n      var _this$props = _this.props,\n          cellLayoutManager = _this$props.cellLayoutManager,\n          onSectionRendered = _this$props.onSectionRendered;\n\n      _this._onSectionRenderedMemoizer({\n        callback: onSectionRendered,\n        indices: {\n          indices: cellLayoutManager.getLastRenderedIndices()\n        }\n      });\n    };\n\n    _this._setScrollingContainerRef = function (ref) {\n      _this._scrollingContainer = ref;\n    };\n\n    _this._updateScrollPositionForScrollToCell = function () {\n      var _this$props2 = _this.props,\n          cellLayoutManager = _this$props2.cellLayoutManager,\n          height = _this$props2.height,\n          scrollToAlignment = _this$props2.scrollToAlignment,\n          scrollToCell = _this$props2.scrollToCell,\n          width = _this$props2.width;\n      var _this$state = _this.state,\n          scrollLeft = _this$state.scrollLeft,\n          scrollTop = _this$state.scrollTop;\n\n      if (scrollToCell >= 0) {\n        var scrollPosition = cellLayoutManager.getScrollPositionForCell({\n          align: scrollToAlignment,\n          cellIndex: scrollToCell,\n          height: height,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          width: width\n        });\n\n        if (scrollPosition.scrollLeft !== scrollLeft || scrollPosition.scrollTop !== scrollTop) {\n          _this._setScrollPosition(scrollPosition);\n        }\n      }\n    };\n\n    _this._onScroll = function (event) {\n      // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.\n      // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.\n      // See issue #404 for more information.\n      if (event.target !== _this._scrollingContainer) {\n        return;\n      } // Prevent pointer events from interrupting a smooth scroll\n\n\n      _this._enablePointerEventsAfterDelay(); // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,\n      // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.\n      // This causes a series of rapid renders that is slow for long lists.\n      // We can avoid that by doing some simple bounds checking to ensure that scrollTop never exceeds the total height.\n\n\n      var _this$props3 = _this.props,\n          cellLayoutManager = _this$props3.cellLayoutManager,\n          height = _this$props3.height,\n          isScrollingChange = _this$props3.isScrollingChange,\n          width = _this$props3.width;\n      var scrollbarSize = _this._scrollbarSize;\n\n      var _cellLayoutManager$ge = cellLayoutManager.getTotalSize(),\n          totalHeight = _cellLayoutManager$ge.height,\n          totalWidth = _cellLayoutManager$ge.width;\n\n      var scrollLeft = Math.max(0, Math.min(totalWidth - width + scrollbarSize, event.target.scrollLeft));\n      var scrollTop = Math.max(0, Math.min(totalHeight - height + scrollbarSize, event.target.scrollTop)); // Certain devices (like Apple touchpad) rapid-fire duplicate events.\n      // Don't force a re-render if this is the case.\n      // The mouse may move faster then the animation frame does.\n      // Use requestAnimationFrame to avoid over-updating.\n\n      if (_this.state.scrollLeft !== scrollLeft || _this.state.scrollTop !== scrollTop) {\n        // Browsers with cancelable scroll events (eg. Firefox) interrupt scrolling animations if scrollTop/scrollLeft is set.\n        // Other browsers (eg. Safari) don't scroll as well without the help under certain conditions (DOM or style changes during scrolling).\n        // All things considered, this seems to be the best current work around that I'm aware of.\n        // For more information see https://github.com/bvaughn/react-virtualized/pull/124\n        var scrollPositionChangeReason = event.cancelable ? SCROLL_POSITION_CHANGE_REASONS.OBSERVED : SCROLL_POSITION_CHANGE_REASONS.REQUESTED; // Synchronously set :isScrolling the first time (since _setNextState will reschedule its animation frame each time it's called)\n\n        if (!_this.state.isScrolling) {\n          isScrollingChange(true);\n        }\n\n        _this.setState({\n          isScrolling: true,\n          scrollLeft: scrollLeft,\n          scrollPositionChangeReason: scrollPositionChangeReason,\n          scrollTop: scrollTop\n        });\n      }\n\n      _this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop,\n        totalWidth: totalWidth,\n        totalHeight: totalHeight\n      });\n    };\n\n    _this._scrollbarSize = getScrollbarSize();\n\n    if (_this._scrollbarSize === undefined) {\n      _this._scrollbarSizeMeasured = false;\n      _this._scrollbarSize = 0;\n    } else {\n      _this._scrollbarSizeMeasured = true;\n    }\n\n    return _this;\n  }\n  /**\n   * Forced recompute of cell sizes and positions.\n   * This function should be called if cell sizes have changed but nothing else has.\n   * Since cell positions are calculated by callbacks, the collection view has no way of detecting when the underlying data has changed.\n   */\n\n\n  _createClass(CollectionView, [{\n    key: 'recomputeCellSizesAndPositions',\n    value: function recomputeCellSizesAndPositions() {\n      this._calculateSizeAndPositionDataOnNextUpdate = true;\n      this.forceUpdate();\n    }\n    /* ---------------------------- Component lifecycle methods ---------------------------- */\n\n    /**\n     * @private\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\n     * 1) Empty content (0 rows or columns)\n     * 2) New scroll props overriding the current state\n     * 3) Cells-count or cells-size has changed, making previous scroll offsets invalid\n     */\n\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var _props = this.props,\n          cellLayoutManager = _props.cellLayoutManager,\n          scrollLeft = _props.scrollLeft,\n          scrollToCell = _props.scrollToCell,\n          scrollTop = _props.scrollTop; // If this component was first rendered server-side, scrollbar size will be undefined.\n      // In that event we need to remeasure.\n\n      if (!this._scrollbarSizeMeasured) {\n        this._scrollbarSize = getScrollbarSize();\n        this._scrollbarSizeMeasured = true;\n        this.setState({});\n      }\n\n      if (scrollToCell >= 0) {\n        this._updateScrollPositionForScrollToCell();\n      } else if (scrollLeft >= 0 || scrollTop >= 0) {\n        this._setScrollPosition({\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        });\n      } // Update onSectionRendered callback.\n\n\n      this._invokeOnSectionRenderedHelper();\n\n      var _cellLayoutManager$ge2 = cellLayoutManager.getTotalSize(),\n          totalHeight = _cellLayoutManager$ge2.height,\n          totalWidth = _cellLayoutManager$ge2.width; // Initialize onScroll callback.\n\n\n      this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft || 0,\n        scrollTop: scrollTop || 0,\n        totalHeight: totalHeight,\n        totalWidth: totalWidth\n      });\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _props2 = this.props,\n          height = _props2.height,\n          scrollToAlignment = _props2.scrollToAlignment,\n          scrollToCell = _props2.scrollToCell,\n          width = _props2.width;\n      var _state = this.state,\n          scrollLeft = _state.scrollLeft,\n          scrollPositionChangeReason = _state.scrollPositionChangeReason,\n          scrollTop = _state.scrollTop; // Make sure requested changes to :scrollLeft or :scrollTop get applied.\n      // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,\n      // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).\n      // So we only set these when we require an adjustment of the scroll position.\n      // See issue #2 for more information.\n\n      if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED) {\n        if (scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft && scrollLeft !== this._scrollingContainer.scrollLeft) {\n          this._scrollingContainer.scrollLeft = scrollLeft;\n        }\n\n        if (scrollTop >= 0 && scrollTop !== prevState.scrollTop && scrollTop !== this._scrollingContainer.scrollTop) {\n          this._scrollingContainer.scrollTop = scrollTop;\n        }\n      } // Update scroll offsets if the current :scrollToCell values requires it\n\n\n      if (height !== prevProps.height || scrollToAlignment !== prevProps.scrollToAlignment || scrollToCell !== prevProps.scrollToCell || width !== prevProps.width) {\n        this._updateScrollPositionForScrollToCell();\n      } // Update onRowsRendered callback if start/stop indices have changed\n\n\n      this._invokeOnSectionRenderedHelper();\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      if (this._disablePointerEventsTimeoutId) {\n        clearTimeout(this._disablePointerEventsTimeoutId);\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props3 = this.props,\n          autoHeight = _props3.autoHeight,\n          cellCount = _props3.cellCount,\n          cellLayoutManager = _props3.cellLayoutManager,\n          className = _props3.className,\n          height = _props3.height,\n          horizontalOverscanSize = _props3.horizontalOverscanSize,\n          id = _props3.id,\n          noContentRenderer = _props3.noContentRenderer,\n          style = _props3.style,\n          verticalOverscanSize = _props3.verticalOverscanSize,\n          width = _props3.width;\n      var _state2 = this.state,\n          isScrolling = _state2.isScrolling,\n          scrollLeft = _state2.scrollLeft,\n          scrollTop = _state2.scrollTop; // Memoization reset\n\n      if (this._lastRenderedCellCount !== cellCount || this._lastRenderedCellLayoutManager !== cellLayoutManager || this._calculateSizeAndPositionDataOnNextUpdate) {\n        this._lastRenderedCellCount = cellCount;\n        this._lastRenderedCellLayoutManager = cellLayoutManager;\n        this._calculateSizeAndPositionDataOnNextUpdate = false;\n        cellLayoutManager.calculateSizeAndPositionData();\n      }\n\n      var _cellLayoutManager$ge3 = cellLayoutManager.getTotalSize(),\n          totalHeight = _cellLayoutManager$ge3.height,\n          totalWidth = _cellLayoutManager$ge3.width; // Safely expand the rendered area by the specified overscan amount\n\n\n      var left = Math.max(0, scrollLeft - horizontalOverscanSize);\n      var top = Math.max(0, scrollTop - verticalOverscanSize);\n      var right = Math.min(totalWidth, scrollLeft + width + horizontalOverscanSize);\n      var bottom = Math.min(totalHeight, scrollTop + height + verticalOverscanSize);\n      var childrenToDisplay = height > 0 && width > 0 ? cellLayoutManager.cellRenderers({\n        height: bottom - top,\n        isScrolling: isScrolling,\n        width: right - left,\n        x: left,\n        y: top\n      }) : [];\n      var collectionStyle = {\n        boxSizing: 'border-box',\n        direction: 'ltr',\n        height: autoHeight ? 'auto' : height,\n        position: 'relative',\n        WebkitOverflowScrolling: 'touch',\n        width: width,\n        willChange: 'transform'\n      }; // Force browser to hide scrollbars when we know they aren't necessary.\n      // Otherwise once scrollbars appear they may not disappear again.\n      // For more info see issue #116\n\n      var verticalScrollBarSize = totalHeight > height ? this._scrollbarSize : 0;\n      var horizontalScrollBarSize = totalWidth > width ? this._scrollbarSize : 0; // Also explicitly init styles to 'auto' if scrollbars are required.\n      // This works around an obscure edge case where external CSS styles have not yet been loaded,\n      // But an initial scroll index of offset is set as an external prop.\n      // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.\n      // This was originally reported via clauderic/react-infinite-calendar/issues/23\n\n      collectionStyle.overflowX = totalWidth + verticalScrollBarSize <= width ? 'hidden' : 'auto';\n      collectionStyle.overflowY = totalHeight + horizontalScrollBarSize <= height ? 'hidden' : 'auto';\n      return React.createElement('div', {\n        ref: this._setScrollingContainerRef,\n        'aria-label': this.props['aria-label'],\n        className: clsx('ReactVirtualized__Collection', className),\n        id: id,\n        onScroll: this._onScroll,\n        role: 'grid',\n        style: _extends({}, collectionStyle, style),\n        tabIndex: 0\n      }, cellCount > 0 && React.createElement('div', {\n        className: 'ReactVirtualized__Collection__innerScrollContainer',\n        style: {\n          height: totalHeight,\n          maxHeight: totalHeight,\n          maxWidth: totalWidth,\n          overflow: 'hidden',\n          pointerEvents: isScrolling ? 'none' : '',\n          width: totalWidth\n        }\n      }, childrenToDisplay), cellCount === 0 && noContentRenderer());\n    }\n    /* ---------------------------- Helper methods ---------------------------- */\n\n    /**\n     * Sets an :isScrolling flag for a small window of time.\n     * This flag is used to disable pointer events on the scrollable portion of the Collection.\n     * This prevents jerky/stuttery mouse-wheel scrolling.\n     */\n\n  }, {\n    key: '_enablePointerEventsAfterDelay',\n    value: function _enablePointerEventsAfterDelay() {\n      var _this2 = this;\n\n      if (this._disablePointerEventsTimeoutId) {\n        clearTimeout(this._disablePointerEventsTimeoutId);\n      }\n\n      this._disablePointerEventsTimeoutId = setTimeout(function () {\n        var isScrollingChange = _this2.props.isScrollingChange;\n        isScrollingChange(false);\n        _this2._disablePointerEventsTimeoutId = null;\n\n        _this2.setState({\n          isScrolling: false\n        });\n      }, IS_SCROLLING_TIMEOUT);\n    }\n  }, {\n    key: '_invokeOnScrollMemoizer',\n    value: function _invokeOnScrollMemoizer(_ref2) {\n      var _this3 = this;\n\n      var scrollLeft = _ref2.scrollLeft,\n          scrollTop = _ref2.scrollTop,\n          totalHeight = _ref2.totalHeight,\n          totalWidth = _ref2.totalWidth;\n\n      this._onScrollMemoizer({\n        callback: function callback(_ref3) {\n          var scrollLeft = _ref3.scrollLeft,\n              scrollTop = _ref3.scrollTop;\n          var _props4 = _this3.props,\n              height = _props4.height,\n              onScroll = _props4.onScroll,\n              width = _props4.width;\n          onScroll({\n            clientHeight: height,\n            clientWidth: width,\n            scrollHeight: totalHeight,\n            scrollLeft: scrollLeft,\n            scrollTop: scrollTop,\n            scrollWidth: totalWidth\n          });\n        },\n        indices: {\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        }\n      });\n    }\n  }, {\n    key: '_setScrollPosition',\n    value: function _setScrollPosition(_ref4) {\n      var scrollLeft = _ref4.scrollLeft,\n          scrollTop = _ref4.scrollTop;\n      var newState = {\n        scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\n      };\n\n      if (scrollLeft >= 0) {\n        newState.scrollLeft = scrollLeft;\n      }\n\n      if (scrollTop >= 0) {\n        newState.scrollTop = scrollTop;\n      }\n\n      if (scrollLeft >= 0 && scrollLeft !== this.state.scrollLeft || scrollTop >= 0 && scrollTop !== this.state.scrollTop) {\n        this.setState(newState);\n      }\n    }\n  }], [{\n    key: 'getDerivedStateFromProps',\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      if (nextProps.cellCount === 0 && (prevState.scrollLeft !== 0 || prevState.scrollTop !== 0)) {\n        return {\n          scrollLeft: 0,\n          scrollTop: 0\n        };\n      } else if (nextProps.scrollLeft !== prevState.scrollLeft || nextProps.scrollTop !== prevState.scrollTop) {\n        return {\n          scrollLeft: nextProps.scrollLeft != null ? nextProps.scrollLeft : prevState.scrollLeft,\n          scrollTop: nextProps.scrollTop != null ? nextProps.scrollTop : prevState.scrollTop\n        };\n      }\n\n      return null;\n    }\n  }]);\n\n  return CollectionView;\n}(React.PureComponent);\n\nCollectionView.defaultProps = {\n  'aria-label': 'grid',\n  horizontalOverscanSize: 0,\n  noContentRenderer: function noContentRenderer() {\n    return null;\n  },\n  onScroll: function onScroll() {\n    return null;\n  },\n  onSectionRendered: function onSectionRendered() {\n    return null;\n  },\n  scrollToAlignment: 'auto',\n  scrollToCell: -1,\n  style: {},\n  verticalOverscanSize: 0\n};\nCollectionView.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  'aria-label': PropTypes.string,\n\n  /**\n   * Removes fixed height from the scrollingContainer so that the total height\n   * of rows can stretch the window. Intended for use with WindowScroller\n   */\n  autoHeight: PropTypes.bool,\n\n  /**\n   * Number of cells in collection.\n   */\n  cellCount: PropTypes.number.isRequired,\n\n  /**\n   * Calculates cell sizes and positions and manages rendering the appropriate cells given a specified window.\n   */\n  cellLayoutManager: PropTypes.object.isRequired,\n\n  /**\n   * Optional custom CSS class name to attach to root Collection element.\n   */\n  className: PropTypes.string,\n\n  /**\n   * Height of Collection; this property determines the number of visible (vs virtualized) rows.\n   */\n  height: PropTypes.number.isRequired,\n\n  /**\n   * Optional custom id to attach to root Collection element.\n   */\n  id: PropTypes.string,\n\n  /**\n   * Enables the `Collection` to horiontally \"overscan\" its content similar to how `Grid` does.\n   * This can reduce flicker around the edges when a user scrolls quickly.\n   */\n  horizontalOverscanSize: PropTypes.number.isRequired,\n  isScrollingChange: PropTypes.func,\n\n  /**\n   * Optional renderer to be used in place of rows when either :rowCount or :cellCount is 0.\n   */\n  noContentRenderer: PropTypes.func.isRequired,\n\n  /**\n   * Callback invoked whenever the scroll offset changes within the inner scrollable region.\n   * This callback can be used to sync scrolling between lists, tables, or grids.\n   * ({ clientHeight, clientWidth, scrollHeight, scrollLeft, scrollTop, scrollWidth }): void\n   */\n  onScroll: PropTypes.func.isRequired,\n\n  /**\n   * Callback invoked with information about the section of the Collection that was just rendered.\n   * This callback is passed a named :indices parameter which is an Array of the most recently rendered section indices.\n   */\n  onSectionRendered: PropTypes.func.isRequired,\n\n  /**\n   * Horizontal offset.\n   */\n  scrollLeft: PropTypes.number,\n\n  /**\n   * Controls scroll-to-cell behavior of the Grid.\n   * The default (\"auto\") scrolls the least amount possible to ensure that the specified cell is fully visible.\n   * Use \"start\" to align cells to the top/left of the Grid and \"end\" to align bottom/right.\n   */\n  scrollToAlignment: PropTypes.oneOf(['auto', 'end', 'start', 'center']).isRequired,\n\n  /**\n   * Cell index to ensure visible (by forcefully scrolling if necessary).\n   */\n  scrollToCell: PropTypes.number.isRequired,\n\n  /**\n   * Vertical offset.\n   */\n  scrollTop: PropTypes.number,\n\n  /**\n   * Optional custom inline style to attach to root Collection element.\n   */\n  style: PropTypes.object,\n\n  /**\n   * Enables the `Collection` to vertically \"overscan\" its content similar to how `Grid` does.\n   * This can reduce flicker around the edges when a user scrolls quickly.\n   */\n  verticalOverscanSize: PropTypes.number.isRequired,\n\n  /**\n   * Width of Collection; this property determines the number of visible (vs virtualized) columns.\n   */\n  width: PropTypes.number.isRequired\n} : {};\npolyfill(CollectionView);\nexport default CollectionView;","map":{"version":3,"sources":["/home/nadaanbaalak/greendeck/client/node_modules/react-virtualized/dist/es/Collection/CollectionView.js"],"names":["_extends","_Object$getPrototypeOf","_classCallCheck","_createClass","_possibleConstructorReturn","_inherits","clsx","PropTypes","React","polyfill","createCallbackMemoizer","getScrollbarSize","IS_SCROLLING_TIMEOUT","SCROLL_POSITION_CHANGE_REASONS","OBSERVED","REQUESTED","CollectionView","_React$PureComponent","_ref","_len","arguments","length","args","Array","_key","_this","__proto__","call","apply","concat","state","isScrolling","scrollLeft","scrollTop","_calculateSizeAndPositionDataOnNextUpdate","_onSectionRenderedMemoizer","_onScrollMemoizer","_invokeOnSectionRenderedHelper","_this$props","props","cellLayoutManager","onSectionRendered","callback","indices","getLastRenderedIndices","_setScrollingContainerRef","ref","_scrollingContainer","_updateScrollPositionForScrollToCell","_this$props2","height","scrollToAlignment","scrollToCell","width","_this$state","scrollPosition","getScrollPositionForCell","align","cellIndex","_setScrollPosition","_onScroll","event","target","_enablePointerEventsAfterDelay","_this$props3","isScrollingChange","scrollbarSize","_scrollbarSize","_cellLayoutManager$ge","getTotalSize","totalHeight","totalWidth","Math","max","min","scrollPositionChangeReason","cancelable","setState","_invokeOnScrollMemoizer","undefined","_scrollbarSizeMeasured","key","value","recomputeCellSizesAndPositions","forceUpdate","componentDidMount","_props","_cellLayoutManager$ge2","componentDidUpdate","prevProps","prevState","_props2","_state","componentWillUnmount","_disablePointerEventsTimeoutId","clearTimeout","render","_props3","autoHeight","cellCount","className","horizontalOverscanSize","id","noContentRenderer","style","verticalOverscanSize","_state2","_lastRenderedCellCount","_lastRenderedCellLayoutManager","calculateSizeAndPositionData","_cellLayoutManager$ge3","left","top","right","bottom","childrenToDisplay","cellRenderers","x","y","collectionStyle","boxSizing","direction","position","WebkitOverflowScrolling","willChange","verticalScrollBarSize","horizontalScrollBarSize","overflowX","overflowY","createElement","onScroll","role","tabIndex","maxHeight","maxWidth","overflow","pointerEvents","_this2","setTimeout","_ref2","_this3","_ref3","_props4","clientHeight","clientWidth","scrollHeight","scrollWidth","_ref4","newState","getDerivedStateFromProps","nextProps","PureComponent","defaultProps","propTypes","process","env","NODE_ENV","string","bool","number","isRequired","object","func","oneOf"],"mappings":"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","sourcesContent":["import _extends from 'babel-runtime/helpers/extends';\nimport _Object$getPrototypeOf from 'babel-runtime/core-js/object/get-prototype-of';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _createClass from 'babel-runtime/helpers/createClass';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\nimport clsx from 'clsx';\nimport PropTypes from 'prop-types';\nimport * as React from 'react';\nimport { polyfill } from 'react-lifecycles-compat';\nimport createCallbackMemoizer from '../utils/createCallbackMemoizer';\nimport getScrollbarSize from 'dom-helpers/scrollbarSize';\n\n// @TODO Merge Collection and CollectionView\n\n/**\n * Specifies the number of milliseconds during which to disable pointer events while a scroll is in progress.\n * This improves performance and makes scrolling smoother.\n */\nvar IS_SCROLLING_TIMEOUT = 150;\n\n/**\n * Controls whether the Grid updates the DOM element's scrollLeft/scrollTop based on the current state or just observes it.\n * This prevents Grid from interrupting mouse-wheel animations (see issue #2).\n */\nvar SCROLL_POSITION_CHANGE_REASONS = {\n  OBSERVED: 'observed',\n  REQUESTED: 'requested'\n};\n\n/**\n * Monitors changes in properties (eg. cellCount) and state (eg. scroll offsets) to determine when rendering needs to occur.\n * This component does not render any visible content itself; it defers to the specified :cellLayoutManager.\n */\n\nvar CollectionView = function (_React$PureComponent) {\n  _inherits(CollectionView, _React$PureComponent);\n\n  // Invokes callbacks only when their values have changed.\n  function CollectionView() {\n    var _ref;\n\n    _classCallCheck(this, CollectionView);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    // If this component is being rendered server-side, getScrollbarSize() will return undefined.\n    // We handle this case in componentDidMount()\n    var _this = _possibleConstructorReturn(this, (_ref = CollectionView.__proto__ || _Object$getPrototypeOf(CollectionView)).call.apply(_ref, [this].concat(args)));\n\n    _this.state = {\n      isScrolling: false,\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n    _this._calculateSizeAndPositionDataOnNextUpdate = false;\n    _this._onSectionRenderedMemoizer = createCallbackMemoizer();\n    _this._onScrollMemoizer = createCallbackMemoizer(false);\n\n    _this._invokeOnSectionRenderedHelper = function () {\n      var _this$props = _this.props,\n          cellLayoutManager = _this$props.cellLayoutManager,\n          onSectionRendered = _this$props.onSectionRendered;\n\n\n      _this._onSectionRenderedMemoizer({\n        callback: onSectionRendered,\n        indices: {\n          indices: cellLayoutManager.getLastRenderedIndices()\n        }\n      });\n    };\n\n    _this._setScrollingContainerRef = function (ref) {\n      _this._scrollingContainer = ref;\n    };\n\n    _this._updateScrollPositionForScrollToCell = function () {\n      var _this$props2 = _this.props,\n          cellLayoutManager = _this$props2.cellLayoutManager,\n          height = _this$props2.height,\n          scrollToAlignment = _this$props2.scrollToAlignment,\n          scrollToCell = _this$props2.scrollToCell,\n          width = _this$props2.width;\n      var _this$state = _this.state,\n          scrollLeft = _this$state.scrollLeft,\n          scrollTop = _this$state.scrollTop;\n\n\n      if (scrollToCell >= 0) {\n        var scrollPosition = cellLayoutManager.getScrollPositionForCell({\n          align: scrollToAlignment,\n          cellIndex: scrollToCell,\n          height: height,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          width: width\n        });\n\n        if (scrollPosition.scrollLeft !== scrollLeft || scrollPosition.scrollTop !== scrollTop) {\n          _this._setScrollPosition(scrollPosition);\n        }\n      }\n    };\n\n    _this._onScroll = function (event) {\n      // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.\n      // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.\n      // See issue #404 for more information.\n      if (event.target !== _this._scrollingContainer) {\n        return;\n      }\n\n      // Prevent pointer events from interrupting a smooth scroll\n      _this._enablePointerEventsAfterDelay();\n\n      // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,\n      // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.\n      // This causes a series of rapid renders that is slow for long lists.\n      // We can avoid that by doing some simple bounds checking to ensure that scrollTop never exceeds the total height.\n      var _this$props3 = _this.props,\n          cellLayoutManager = _this$props3.cellLayoutManager,\n          height = _this$props3.height,\n          isScrollingChange = _this$props3.isScrollingChange,\n          width = _this$props3.width;\n\n      var scrollbarSize = _this._scrollbarSize;\n\n      var _cellLayoutManager$ge = cellLayoutManager.getTotalSize(),\n          totalHeight = _cellLayoutManager$ge.height,\n          totalWidth = _cellLayoutManager$ge.width;\n\n      var scrollLeft = Math.max(0, Math.min(totalWidth - width + scrollbarSize, event.target.scrollLeft));\n      var scrollTop = Math.max(0, Math.min(totalHeight - height + scrollbarSize, event.target.scrollTop));\n\n      // Certain devices (like Apple touchpad) rapid-fire duplicate events.\n      // Don't force a re-render if this is the case.\n      // The mouse may move faster then the animation frame does.\n      // Use requestAnimationFrame to avoid over-updating.\n      if (_this.state.scrollLeft !== scrollLeft || _this.state.scrollTop !== scrollTop) {\n        // Browsers with cancelable scroll events (eg. Firefox) interrupt scrolling animations if scrollTop/scrollLeft is set.\n        // Other browsers (eg. Safari) don't scroll as well without the help under certain conditions (DOM or style changes during scrolling).\n        // All things considered, this seems to be the best current work around that I'm aware of.\n        // For more information see https://github.com/bvaughn/react-virtualized/pull/124\n        var scrollPositionChangeReason = event.cancelable ? SCROLL_POSITION_CHANGE_REASONS.OBSERVED : SCROLL_POSITION_CHANGE_REASONS.REQUESTED;\n\n        // Synchronously set :isScrolling the first time (since _setNextState will reschedule its animation frame each time it's called)\n        if (!_this.state.isScrolling) {\n          isScrollingChange(true);\n        }\n\n        _this.setState({\n          isScrolling: true,\n          scrollLeft: scrollLeft,\n          scrollPositionChangeReason: scrollPositionChangeReason,\n          scrollTop: scrollTop\n        });\n      }\n\n      _this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop,\n        totalWidth: totalWidth,\n        totalHeight: totalHeight\n      });\n    };\n\n    _this._scrollbarSize = getScrollbarSize();\n    if (_this._scrollbarSize === undefined) {\n      _this._scrollbarSizeMeasured = false;\n      _this._scrollbarSize = 0;\n    } else {\n      _this._scrollbarSizeMeasured = true;\n    }\n    return _this;\n  }\n\n  /**\n   * Forced recompute of cell sizes and positions.\n   * This function should be called if cell sizes have changed but nothing else has.\n   * Since cell positions are calculated by callbacks, the collection view has no way of detecting when the underlying data has changed.\n   */\n\n\n  _createClass(CollectionView, [{\n    key: 'recomputeCellSizesAndPositions',\n    value: function recomputeCellSizesAndPositions() {\n      this._calculateSizeAndPositionDataOnNextUpdate = true;\n      this.forceUpdate();\n    }\n\n    /* ---------------------------- Component lifecycle methods ---------------------------- */\n\n    /**\n     * @private\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\n     * 1) Empty content (0 rows or columns)\n     * 2) New scroll props overriding the current state\n     * 3) Cells-count or cells-size has changed, making previous scroll offsets invalid\n     */\n\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var _props = this.props,\n          cellLayoutManager = _props.cellLayoutManager,\n          scrollLeft = _props.scrollLeft,\n          scrollToCell = _props.scrollToCell,\n          scrollTop = _props.scrollTop;\n\n      // If this component was first rendered server-side, scrollbar size will be undefined.\n      // In that event we need to remeasure.\n\n      if (!this._scrollbarSizeMeasured) {\n        this._scrollbarSize = getScrollbarSize();\n        this._scrollbarSizeMeasured = true;\n        this.setState({});\n      }\n\n      if (scrollToCell >= 0) {\n        this._updateScrollPositionForScrollToCell();\n      } else if (scrollLeft >= 0 || scrollTop >= 0) {\n        this._setScrollPosition({ scrollLeft: scrollLeft, scrollTop: scrollTop });\n      }\n\n      // Update onSectionRendered callback.\n      this._invokeOnSectionRenderedHelper();\n\n      var _cellLayoutManager$ge2 = cellLayoutManager.getTotalSize(),\n          totalHeight = _cellLayoutManager$ge2.height,\n          totalWidth = _cellLayoutManager$ge2.width;\n\n      // Initialize onScroll callback.\n\n\n      this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft || 0,\n        scrollTop: scrollTop || 0,\n        totalHeight: totalHeight,\n        totalWidth: totalWidth\n      });\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _props2 = this.props,\n          height = _props2.height,\n          scrollToAlignment = _props2.scrollToAlignment,\n          scrollToCell = _props2.scrollToCell,\n          width = _props2.width;\n      var _state = this.state,\n          scrollLeft = _state.scrollLeft,\n          scrollPositionChangeReason = _state.scrollPositionChangeReason,\n          scrollTop = _state.scrollTop;\n\n      // Make sure requested changes to :scrollLeft or :scrollTop get applied.\n      // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,\n      // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).\n      // So we only set these when we require an adjustment of the scroll position.\n      // See issue #2 for more information.\n\n      if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED) {\n        if (scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft && scrollLeft !== this._scrollingContainer.scrollLeft) {\n          this._scrollingContainer.scrollLeft = scrollLeft;\n        }\n        if (scrollTop >= 0 && scrollTop !== prevState.scrollTop && scrollTop !== this._scrollingContainer.scrollTop) {\n          this._scrollingContainer.scrollTop = scrollTop;\n        }\n      }\n\n      // Update scroll offsets if the current :scrollToCell values requires it\n      if (height !== prevProps.height || scrollToAlignment !== prevProps.scrollToAlignment || scrollToCell !== prevProps.scrollToCell || width !== prevProps.width) {\n        this._updateScrollPositionForScrollToCell();\n      }\n\n      // Update onRowsRendered callback if start/stop indices have changed\n      this._invokeOnSectionRenderedHelper();\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      if (this._disablePointerEventsTimeoutId) {\n        clearTimeout(this._disablePointerEventsTimeoutId);\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props3 = this.props,\n          autoHeight = _props3.autoHeight,\n          cellCount = _props3.cellCount,\n          cellLayoutManager = _props3.cellLayoutManager,\n          className = _props3.className,\n          height = _props3.height,\n          horizontalOverscanSize = _props3.horizontalOverscanSize,\n          id = _props3.id,\n          noContentRenderer = _props3.noContentRenderer,\n          style = _props3.style,\n          verticalOverscanSize = _props3.verticalOverscanSize,\n          width = _props3.width;\n      var _state2 = this.state,\n          isScrolling = _state2.isScrolling,\n          scrollLeft = _state2.scrollLeft,\n          scrollTop = _state2.scrollTop;\n\n      // Memoization reset\n\n      if (this._lastRenderedCellCount !== cellCount || this._lastRenderedCellLayoutManager !== cellLayoutManager || this._calculateSizeAndPositionDataOnNextUpdate) {\n        this._lastRenderedCellCount = cellCount;\n        this._lastRenderedCellLayoutManager = cellLayoutManager;\n        this._calculateSizeAndPositionDataOnNextUpdate = false;\n\n        cellLayoutManager.calculateSizeAndPositionData();\n      }\n\n      var _cellLayoutManager$ge3 = cellLayoutManager.getTotalSize(),\n          totalHeight = _cellLayoutManager$ge3.height,\n          totalWidth = _cellLayoutManager$ge3.width;\n\n      // Safely expand the rendered area by the specified overscan amount\n\n\n      var left = Math.max(0, scrollLeft - horizontalOverscanSize);\n      var top = Math.max(0, scrollTop - verticalOverscanSize);\n      var right = Math.min(totalWidth, scrollLeft + width + horizontalOverscanSize);\n      var bottom = Math.min(totalHeight, scrollTop + height + verticalOverscanSize);\n\n      var childrenToDisplay = height > 0 && width > 0 ? cellLayoutManager.cellRenderers({\n        height: bottom - top,\n        isScrolling: isScrolling,\n        width: right - left,\n        x: left,\n        y: top\n      }) : [];\n\n      var collectionStyle = {\n        boxSizing: 'border-box',\n        direction: 'ltr',\n        height: autoHeight ? 'auto' : height,\n        position: 'relative',\n        WebkitOverflowScrolling: 'touch',\n        width: width,\n        willChange: 'transform'\n      };\n\n      // Force browser to hide scrollbars when we know they aren't necessary.\n      // Otherwise once scrollbars appear they may not disappear again.\n      // For more info see issue #116\n      var verticalScrollBarSize = totalHeight > height ? this._scrollbarSize : 0;\n      var horizontalScrollBarSize = totalWidth > width ? this._scrollbarSize : 0;\n\n      // Also explicitly init styles to 'auto' if scrollbars are required.\n      // This works around an obscure edge case where external CSS styles have not yet been loaded,\n      // But an initial scroll index of offset is set as an external prop.\n      // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.\n      // This was originally reported via clauderic/react-infinite-calendar/issues/23\n      collectionStyle.overflowX = totalWidth + verticalScrollBarSize <= width ? 'hidden' : 'auto';\n      collectionStyle.overflowY = totalHeight + horizontalScrollBarSize <= height ? 'hidden' : 'auto';\n\n      return React.createElement(\n        'div',\n        {\n          ref: this._setScrollingContainerRef,\n          'aria-label': this.props['aria-label'],\n          className: clsx('ReactVirtualized__Collection', className),\n          id: id,\n          onScroll: this._onScroll,\n          role: 'grid',\n          style: _extends({}, collectionStyle, style),\n          tabIndex: 0 },\n        cellCount > 0 && React.createElement(\n          'div',\n          {\n            className: 'ReactVirtualized__Collection__innerScrollContainer',\n            style: {\n              height: totalHeight,\n              maxHeight: totalHeight,\n              maxWidth: totalWidth,\n              overflow: 'hidden',\n              pointerEvents: isScrolling ? 'none' : '',\n              width: totalWidth\n            } },\n          childrenToDisplay\n        ),\n        cellCount === 0 && noContentRenderer()\n      );\n    }\n\n    /* ---------------------------- Helper methods ---------------------------- */\n\n    /**\n     * Sets an :isScrolling flag for a small window of time.\n     * This flag is used to disable pointer events on the scrollable portion of the Collection.\n     * This prevents jerky/stuttery mouse-wheel scrolling.\n     */\n\n  }, {\n    key: '_enablePointerEventsAfterDelay',\n    value: function _enablePointerEventsAfterDelay() {\n      var _this2 = this;\n\n      if (this._disablePointerEventsTimeoutId) {\n        clearTimeout(this._disablePointerEventsTimeoutId);\n      }\n\n      this._disablePointerEventsTimeoutId = setTimeout(function () {\n        var isScrollingChange = _this2.props.isScrollingChange;\n\n\n        isScrollingChange(false);\n\n        _this2._disablePointerEventsTimeoutId = null;\n        _this2.setState({\n          isScrolling: false\n        });\n      }, IS_SCROLLING_TIMEOUT);\n    }\n  }, {\n    key: '_invokeOnScrollMemoizer',\n    value: function _invokeOnScrollMemoizer(_ref2) {\n      var _this3 = this;\n\n      var scrollLeft = _ref2.scrollLeft,\n          scrollTop = _ref2.scrollTop,\n          totalHeight = _ref2.totalHeight,\n          totalWidth = _ref2.totalWidth;\n\n      this._onScrollMemoizer({\n        callback: function callback(_ref3) {\n          var scrollLeft = _ref3.scrollLeft,\n              scrollTop = _ref3.scrollTop;\n          var _props4 = _this3.props,\n              height = _props4.height,\n              onScroll = _props4.onScroll,\n              width = _props4.width;\n\n\n          onScroll({\n            clientHeight: height,\n            clientWidth: width,\n            scrollHeight: totalHeight,\n            scrollLeft: scrollLeft,\n            scrollTop: scrollTop,\n            scrollWidth: totalWidth\n          });\n        },\n        indices: {\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        }\n      });\n    }\n  }, {\n    key: '_setScrollPosition',\n    value: function _setScrollPosition(_ref4) {\n      var scrollLeft = _ref4.scrollLeft,\n          scrollTop = _ref4.scrollTop;\n\n      var newState = {\n        scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\n      };\n\n      if (scrollLeft >= 0) {\n        newState.scrollLeft = scrollLeft;\n      }\n\n      if (scrollTop >= 0) {\n        newState.scrollTop = scrollTop;\n      }\n\n      if (scrollLeft >= 0 && scrollLeft !== this.state.scrollLeft || scrollTop >= 0 && scrollTop !== this.state.scrollTop) {\n        this.setState(newState);\n      }\n    }\n  }], [{\n    key: 'getDerivedStateFromProps',\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      if (nextProps.cellCount === 0 && (prevState.scrollLeft !== 0 || prevState.scrollTop !== 0)) {\n        return {\n          scrollLeft: 0,\n          scrollTop: 0\n        };\n      } else if (nextProps.scrollLeft !== prevState.scrollLeft || nextProps.scrollTop !== prevState.scrollTop) {\n        return {\n          scrollLeft: nextProps.scrollLeft != null ? nextProps.scrollLeft : prevState.scrollLeft,\n          scrollTop: nextProps.scrollTop != null ? nextProps.scrollTop : prevState.scrollTop\n        };\n      }\n\n      return null;\n    }\n  }]);\n\n  return CollectionView;\n}(React.PureComponent);\n\nCollectionView.defaultProps = {\n  'aria-label': 'grid',\n  horizontalOverscanSize: 0,\n  noContentRenderer: function noContentRenderer() {\n    return null;\n  },\n  onScroll: function onScroll() {\n    return null;\n  },\n  onSectionRendered: function onSectionRendered() {\n    return null;\n  },\n  scrollToAlignment: 'auto',\n  scrollToCell: -1,\n  style: {},\n  verticalOverscanSize: 0\n};\nCollectionView.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  'aria-label': PropTypes.string,\n\n  /**\n   * Removes fixed height from the scrollingContainer so that the total height\n   * of rows can stretch the window. Intended for use with WindowScroller\n   */\n  autoHeight: PropTypes.bool,\n\n  /**\n   * Number of cells in collection.\n   */\n  cellCount: PropTypes.number.isRequired,\n\n  /**\n   * Calculates cell sizes and positions and manages rendering the appropriate cells given a specified window.\n   */\n  cellLayoutManager: PropTypes.object.isRequired,\n\n  /**\n   * Optional custom CSS class name to attach to root Collection element.\n   */\n  className: PropTypes.string,\n\n  /**\n   * Height of Collection; this property determines the number of visible (vs virtualized) rows.\n   */\n  height: PropTypes.number.isRequired,\n\n  /**\n   * Optional custom id to attach to root Collection element.\n   */\n  id: PropTypes.string,\n\n  /**\n   * Enables the `Collection` to horiontally \"overscan\" its content similar to how `Grid` does.\n   * This can reduce flicker around the edges when a user scrolls quickly.\n   */\n  horizontalOverscanSize: PropTypes.number.isRequired,\n\n  isScrollingChange: PropTypes.func,\n\n  /**\n   * Optional renderer to be used in place of rows when either :rowCount or :cellCount is 0.\n   */\n  noContentRenderer: PropTypes.func.isRequired,\n\n  /**\n   * Callback invoked whenever the scroll offset changes within the inner scrollable region.\n   * This callback can be used to sync scrolling between lists, tables, or grids.\n   * ({ clientHeight, clientWidth, scrollHeight, scrollLeft, scrollTop, scrollWidth }): void\n   */\n  onScroll: PropTypes.func.isRequired,\n\n  /**\n   * Callback invoked with information about the section of the Collection that was just rendered.\n   * This callback is passed a named :indices parameter which is an Array of the most recently rendered section indices.\n   */\n  onSectionRendered: PropTypes.func.isRequired,\n\n  /**\n   * Horizontal offset.\n   */\n  scrollLeft: PropTypes.number,\n\n  /**\n   * Controls scroll-to-cell behavior of the Grid.\n   * The default (\"auto\") scrolls the least amount possible to ensure that the specified cell is fully visible.\n   * Use \"start\" to align cells to the top/left of the Grid and \"end\" to align bottom/right.\n   */\n  scrollToAlignment: PropTypes.oneOf(['auto', 'end', 'start', 'center']).isRequired,\n\n  /**\n   * Cell index to ensure visible (by forcefully scrolling if necessary).\n   */\n  scrollToCell: PropTypes.number.isRequired,\n\n  /**\n   * Vertical offset.\n   */\n  scrollTop: PropTypes.number,\n\n  /**\n   * Optional custom inline style to attach to root Collection element.\n   */\n  style: PropTypes.object,\n\n  /**\n   * Enables the `Collection` to vertically \"overscan\" its content similar to how `Grid` does.\n   * This can reduce flicker around the edges when a user scrolls quickly.\n   */\n  verticalOverscanSize: PropTypes.number.isRequired,\n\n  /**\n   * Width of Collection; this property determines the number of visible (vs virtualized) columns.\n   */\n  width: PropTypes.number.isRequired\n} : {};\n\n\npolyfill(CollectionView);\n\nexport default CollectionView;"]},"metadata":{},"sourceType":"module"}