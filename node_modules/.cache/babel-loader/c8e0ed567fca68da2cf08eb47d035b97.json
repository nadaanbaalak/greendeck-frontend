{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\nimport { isArray, isNil } from '../../../services/predicate';\nimport { dateValuesEqual, isDateValue } from './date_value';\nexport var Match = Object.freeze({\n  MUST: 'must',\n  MUST_NOT: 'must_not',\n  isMust: function isMust(match) {\n    return match === Match.MUST;\n  },\n  isMustClause: function isMustClause(clause) {\n    return Match.isMust(clause.match);\n  }\n});\nexport var Operator = Object.freeze({\n  EQ: 'eq',\n  EXACT: 'exact',\n  GT: 'gt',\n  GTE: 'gte',\n  LT: 'lt',\n  LTE: 'lte',\n  isEQ: function isEQ(match) {\n    return match === Operator.EQ;\n  },\n  isEQClause: function isEQClause(clause) {\n    return Field.isInstance(clause) && Operator.isEQ(clause.operator);\n  },\n  isEXACT: function isEXACT(match) {\n    return match === Operator.EXACT;\n  },\n  isEXACTClause: function isEXACTClause(clause) {\n    return Field.isInstance(clause) && Operator.isEXACT(clause.operator);\n  },\n  isRange: function isRange(match) {\n    return Operator.isGT(match) || Operator.isGTE(match) || Operator.isLT(match) || Operator.isLTE(match);\n  },\n  isRangeClause: function isRangeClause(clause) {\n    return Field.isInstance(clause) && Operator.isRange(clause.operator);\n  },\n  isGT: function isGT(match) {\n    return match === Operator.GT;\n  },\n  isGTClause: function isGTClause(clause) {\n    return Field.isInstance(clause) && Operator.isGT(clause.operator);\n  },\n  isGTE: function isGTE(match) {\n    return match === Operator.GTE;\n  },\n  isGTEClause: function isGTEClause(clause) {\n    return Field.isInstance(clause) && Operator.isGTE(clause.operator);\n  },\n  isLT: function isLT(match) {\n    return match === Operator.LT;\n  },\n  isLTClause: function isLTClause(clause) {\n    return Field.isInstance(clause) && Operator.isLT(clause.operator);\n  },\n  isLTE: function isLTE(match) {\n    return match === Operator.LTE;\n  },\n  isLTEClause: function isLTEClause(clause) {\n    return Field.isInstance(clause) && Operator.isLTE(clause.operator);\n  }\n});\nvar Term = Object.freeze({\n  TYPE: 'term',\n  isInstance: function isInstance(clause) {\n    return clause.type === Term.TYPE;\n  },\n  must: function must(value) {\n    return {\n      type: Term.TYPE,\n      value: value,\n      match: Match.MUST\n    };\n  },\n  mustNot: function mustNot(value) {\n    return {\n      type: Term.TYPE,\n      value: value,\n      match: Match.MUST_NOT\n    };\n  }\n});\nvar Group = Object.freeze({\n  TYPE: 'group',\n  isInstance: function isInstance(clause) {\n    return clause.type === Group.TYPE;\n  },\n  must: function must(value) {\n    return {\n      type: Group.TYPE,\n      value: value,\n      match: Match.MUST\n    };\n  },\n  mustNot: function mustNot(value) {\n    return {\n      type: Group.TYPE,\n      value: value,\n      match: Match.MUST_NOT\n    };\n  }\n});\nvar Field = Object.freeze({\n  TYPE: 'field',\n  isInstance: function isInstance(clause) {\n    return clause.type === Field.TYPE;\n  },\n  must: {\n    eq: function eq(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.EQ\n      };\n    },\n    exact: function exact(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.EXACT\n      };\n    },\n    gt: function gt(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.GT\n      };\n    },\n    gte: function gte(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.GTE\n      };\n    },\n    lt: function lt(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.LT\n      };\n    },\n    lte: function lte(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.LTE\n      };\n    }\n  },\n  mustNot: {\n    eq: function eq(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.EQ\n      };\n    },\n    exact: function exact(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.EXACT\n      };\n    },\n    gt: function gt(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.GT\n      };\n    },\n    gte: function gte(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.GTE\n      };\n    },\n    lt: function lt(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.LT\n      };\n    },\n    lte: function lte(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.LTE\n      };\n    }\n  }\n});\nvar Is = Object.freeze({\n  TYPE: 'is',\n  isInstance: function isInstance(clause) {\n    return clause.type === Is.TYPE;\n  },\n  must: function must(flag) {\n    return {\n      type: Is.TYPE,\n      flag: flag,\n      match: Match.MUST\n    };\n  },\n  mustNot: function mustNot(flag) {\n    return {\n      type: Is.TYPE,\n      flag: flag,\n      match: Match.MUST_NOT\n    };\n  }\n});\n\nvar valuesEqual = function valuesEqual(v1, v2) {\n  if (isDateValue(v1)) {\n    return dateValuesEqual(v1, v2);\n  }\n\n  return v1 === v2;\n};\n\nvar arrayIncludesValue = function arrayIncludesValue(array, value) {\n  return array.some(function (item) {\n    return valuesEqual(item, value);\n  });\n};\n/**\n * The AST structure is an array of clauses. There are 3 types of clauses that are supported:\n *\n * :term:\n * Holds a VALUE and an OCCUR. The OCCUR indicates whether the value must match or must not match. Default\n * clauses are not associated with any specific field - when executing the search, one can specify what are\n * the default fields that the default clauses will be matched against.\n *\n * :field:\n * Like the `term` clause, holds a VALUE and an MATCH, but this clause also specifies the field that the\n * value will be matched against.\n *\n * :is:\n * Holds a FLAG and indicates whether this flag must be applied or must not be applied. Typically this clause\n * matches against boolean values of a record (e.g. \"is:online\", \"is:internal\", \"is:on\", etc..)\n *\n * This AST is immutable - every \"mutating\" operation returns a newly mutated AST.\n */\n\n\nexport var _AST = /*#__PURE__*/function () {\n  _createClass(_AST, null, [{\n    key: \"create\",\n    value: function create(clauses) {\n      return new _AST(clauses);\n    }\n  }]);\n\n  function _AST() {\n    var _this = this;\n\n    var clauses = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    _classCallCheck(this, _AST);\n\n    _defineProperty(this, \"_clauses\", void 0);\n\n    _defineProperty(this, \"_indexedClauses\", void 0);\n\n    this._clauses = clauses;\n    this._indexedClauses = {\n      field: {},\n      is: {},\n      term: [],\n      group: []\n    };\n    clauses.forEach(function (clause) {\n      switch (clause.type) {\n        case Field.TYPE:\n          if (!_this._indexedClauses.field[clause.field]) {\n            _this._indexedClauses.field[clause.field] = [];\n          }\n\n          _this._indexedClauses.field[clause.field].push(clause);\n\n          break;\n\n        case Is.TYPE:\n          _this._indexedClauses.is[clause.flag] = clause;\n          break;\n\n        case Term.TYPE:\n          _this._indexedClauses.term.push(clause);\n\n          break;\n\n        case Group.TYPE:\n          _this._indexedClauses.group.push(clause);\n\n          break;\n\n        default:\n          // @ts-ignore TS knows we have exhausted the match\n          throw new Error(\"Unknown query clause type [\".concat(clause.type, \"]\"));\n      }\n    });\n  }\n\n  _createClass(_AST, [{\n    key: \"getTermClauses\",\n    value: function getTermClauses() {\n      return this._indexedClauses.term;\n    }\n  }, {\n    key: \"getTermClause\",\n    value: function getTermClause(value) {\n      var clauses = this.getTermClauses();\n      return clauses.find(function (clause) {\n        return valuesEqual(clause.value, value);\n      });\n    }\n  }, {\n    key: \"getFieldNames\",\n    value: function getFieldNames() {\n      return Object.keys(this._indexedClauses.field);\n    }\n  }, {\n    key: \"getFieldClauses\",\n    value: function getFieldClauses(field) {\n      return field ? this._indexedClauses.field[field] : this._clauses.filter(Field.isInstance);\n    }\n  }, {\n    key: \"getFieldClause\",\n    value: function getFieldClause(field, predicate) {\n      var clauses = this.getFieldClauses(field);\n\n      if (clauses) {\n        return clauses.find(predicate);\n      }\n    }\n  }, {\n    key: \"hasOrFieldClause\",\n    value: function hasOrFieldClause(field, value) {\n      var clause = this.getFieldClause(field, function (clause) {\n        return isArray(clause.value);\n      });\n\n      if (!clause) {\n        return false;\n      } // We can apply this type cast due to the `isArray` filter above\n\n\n      return isNil(value) || arrayIncludesValue(clause.value, value);\n    }\n  }, {\n    key: \"getOrFieldClause\",\n    value: function getOrFieldClause(field, value) {\n      return this.getFieldClause(field, function (clause) {\n        return isArray(clause.value) && (isNil(value) || arrayIncludesValue(clause.value, value));\n      });\n    }\n  }, {\n    key: \"addOrFieldValue\",\n    value: function addOrFieldValue(field, value) {\n      var must = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var operator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Operator.EQ;\n      var existingClause = this.getOrFieldClause(field);\n\n      if (!existingClause) {\n        var newClause = must ? Field.must[operator](field, [value]) : Field.mustNot[operator](field, [value]);\n        return new _AST([].concat(_toConsumableArray(this._clauses), [newClause]));\n      }\n\n      var clauses = this._clauses.map(function (clause) {\n        if (clause === existingClause) {\n          clause.value.push(value);\n        }\n\n        return clause;\n      });\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"removeOrFieldValue\",\n    value: function removeOrFieldValue(field, value) {\n      var existingClause = this.getOrFieldClause(field, value);\n\n      if (!existingClause) {\n        return new _AST(_toConsumableArray(this._clauses));\n      }\n\n      var clauses = this._clauses.reduce(function (clauses, clause) {\n        if (clause !== existingClause) {\n          clauses.push(clause);\n          return clauses;\n        }\n\n        var filteredValue = clause.value.filter(function (val) {\n          return !valuesEqual(val, value);\n        });\n\n        if (filteredValue.length === 0) {\n          return clauses;\n        }\n\n        clauses.push(_objectSpread({}, clause, {\n          value: filteredValue\n        }));\n        return clauses;\n      }, []);\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"removeOrFieldClauses\",\n    value: function removeOrFieldClauses(field) {\n      var clauses = this._clauses.filter(function (clause) {\n        return !Field.isInstance(clause) || clause.field !== field || !isArray(clause.value);\n      });\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"hasSimpleFieldClause\",\n    value: function hasSimpleFieldClause(field, value) {\n      var clause = this.getFieldClause(field, function (clause) {\n        return !isArray(clause.value);\n      });\n\n      if (!clause) {\n        return false;\n      }\n\n      return isNil(value) || valuesEqual(clause.value, value);\n    }\n  }, {\n    key: \"getSimpleFieldClause\",\n    value: function getSimpleFieldClause(field, value) {\n      return this.getFieldClause(field, function (clause) {\n        return !isArray(clause.value) && (isNil(value) || valuesEqual(clause.value, value));\n      });\n    }\n  }, {\n    key: \"addSimpleFieldValue\",\n    value: function addSimpleFieldValue(field, value) {\n      var must = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var operator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Operator.EQ;\n      var clause = must ? Field.must[operator](field, value) : Field.mustNot[operator](field, value);\n      return this.addClause(clause);\n    }\n  }, {\n    key: \"removeSimpleFieldValue\",\n    value: function removeSimpleFieldValue(field, value) {\n      var existingClause = this.getSimpleFieldClause(field, value);\n\n      if (!existingClause) {\n        return new _AST(_toConsumableArray(this._clauses));\n      }\n\n      var clauses = this._clauses.filter(function (clause) {\n        return clause !== existingClause;\n      });\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"removeSimpleFieldClauses\",\n    value: function removeSimpleFieldClauses(field) {\n      var clauses = this._clauses.filter(function (clause) {\n        return !Field.isInstance(clause) || clause.field !== field || isArray(clause.value);\n      });\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"getIsClauses\",\n    value: function getIsClauses() {\n      return Object.values(this._indexedClauses.is);\n    }\n  }, {\n    key: \"getIsClause\",\n    value: function getIsClause(flag) {\n      return this._indexedClauses.is[flag];\n    }\n  }, {\n    key: \"removeIsClause\",\n    value: function removeIsClause(flag) {\n      return new _AST(this._clauses.filter(function (clause) {\n        return !Is.isInstance(clause) || clause.flag !== flag;\n      }));\n    }\n  }, {\n    key: \"getGroupClauses\",\n    value: function getGroupClauses() {\n      return Object.values(this._indexedClauses.group);\n    }\n    /**\n     * Creates and returns a new AST with the given clause added to the current clauses. If\n     * the current clauses already include a similar clause, it will be (in-place) replaced by\n     * the given clause. Whether a clause is similar to the given one depends on the type of the clause.\n     * Two clauses are similar if:\n     *\n     * - they are both of the same type\n     * - if they are `default` clauses, they must have the same value\n     * - if they are `term` clauses, they must have the same fields and values\n     * - if they are `is` clauses, they must have the same flags\n     *\n     * The reasoning behind not including the `match` attributes of the clauses in the rules above, stems\n     * in the fact that the AST clauses are ANDed, and having two similar clauses with two different\n     * match attributes creates a logically contradicted AST (e.g. what does it mean to\n     * \"(must have x) AND (must not have x)\"?)\n     *\n     * note:  in-place replacement means the given clause will be placed in the same position as the one it\n     *        replaced\n     */\n\n  }, {\n    key: \"addClause\",\n    value: function addClause(newClause) {\n      var added = false;\n\n      var newClauses = this._clauses.reduce(function (clauses, clause) {\n        if (newClause.type !== clause.type) {\n          clauses.push(clause);\n          return clauses;\n        }\n\n        switch (newClause.type) {\n          case Term.TYPE:\n            if (newClause.value !== clause.value) {\n              clauses.push(clause);\n              return clauses;\n            }\n\n            break;\n\n          case Field.TYPE:\n            if (newClause.field !== clause.field || newClause.value !== clause.value) {\n              clauses.push(clause);\n              return clauses;\n            }\n\n            break;\n\n          case Is.TYPE:\n            if (newClause.flag !== clause.flag) {\n              clauses.push(clause);\n              return clauses;\n            }\n\n            break;\n\n          default:\n            throw new Error(\"unknown clause type [\".concat(newClause.type, \"]\"));\n        }\n\n        added = true;\n        clauses.push(newClause);\n        return clauses;\n      }, []);\n\n      if (!added) {\n        newClauses.push(newClause);\n      }\n\n      return new _AST(newClauses);\n    }\n  }, {\n    key: \"clauses\",\n    get: function get() {\n      return this._clauses;\n    }\n  }]);\n\n  return _AST;\n}();\nexport var AST = Object.freeze({\n  Match: Match,\n  Operator: Operator,\n  Term: Term,\n  Group: Group,\n  Field: Field,\n  Is: Is,\n  create: function create(clauses) {\n    return new _AST(clauses);\n  }\n});","map":{"version":3,"sources":["/home/nadaanbaalak/greendeck/client/node_modules/@elastic/eui/es/components/search_bar/query/ast.js"],"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","prototype","toString","call","Array","from","isArray","arr2","_classCallCheck","instance","Constructor","_defineProperties","props","descriptor","configurable","writable","_createClass","protoProps","staticProps","obj","value","isNil","dateValuesEqual","isDateValue","Match","freeze","MUST","MUST_NOT","isMust","match","isMustClause","clause","Operator","EQ","EXACT","GT","GTE","LT","LTE","isEQ","isEQClause","Field","isInstance","operator","isEXACT","isEXACTClause","isRange","isGT","isGTE","isLT","isLTE","isRangeClause","isGTClause","isGTEClause","isLTClause","isLTEClause","Term","TYPE","type","must","mustNot","Group","eq","field","exact","gt","gte","lt","lte","Is","flag","valuesEqual","v1","v2","arrayIncludesValue","array","some","item","_AST","create","clauses","_this","undefined","_clauses","_indexedClauses","is","term","group","Error","concat","getTermClauses","getTermClause","find","getFieldNames","getFieldClauses","getFieldClause","predicate","hasOrFieldClause","getOrFieldClause","addOrFieldValue","existingClause","newClause","map","removeOrFieldValue","reduce","filteredValue","val","removeOrFieldClauses","hasSimpleFieldClause","getSimpleFieldClause","addSimpleFieldValue","addClause","removeSimpleFieldValue","removeSimpleFieldClauses","getIsClauses","values","getIsClause","removeIsClause","getGroupClauses","added","newClauses","get","AST"],"mappings":"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","sourcesContent":["function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { isArray, isNil } from '../../../services/predicate';\nimport { dateValuesEqual, isDateValue } from './date_value';\nexport var Match = Object.freeze({\n  MUST: 'must',\n  MUST_NOT: 'must_not',\n  isMust: function isMust(match) {\n    return match === Match.MUST;\n  },\n  isMustClause: function isMustClause(clause) {\n    return Match.isMust(clause.match);\n  }\n});\nexport var Operator = Object.freeze({\n  EQ: 'eq',\n  EXACT: 'exact',\n  GT: 'gt',\n  GTE: 'gte',\n  LT: 'lt',\n  LTE: 'lte',\n  isEQ: function isEQ(match) {\n    return match === Operator.EQ;\n  },\n  isEQClause: function isEQClause(clause) {\n    return Field.isInstance(clause) && Operator.isEQ(clause.operator);\n  },\n  isEXACT: function isEXACT(match) {\n    return match === Operator.EXACT;\n  },\n  isEXACTClause: function isEXACTClause(clause) {\n    return Field.isInstance(clause) && Operator.isEXACT(clause.operator);\n  },\n  isRange: function isRange(match) {\n    return Operator.isGT(match) || Operator.isGTE(match) || Operator.isLT(match) || Operator.isLTE(match);\n  },\n  isRangeClause: function isRangeClause(clause) {\n    return Field.isInstance(clause) && Operator.isRange(clause.operator);\n  },\n  isGT: function isGT(match) {\n    return match === Operator.GT;\n  },\n  isGTClause: function isGTClause(clause) {\n    return Field.isInstance(clause) && Operator.isGT(clause.operator);\n  },\n  isGTE: function isGTE(match) {\n    return match === Operator.GTE;\n  },\n  isGTEClause: function isGTEClause(clause) {\n    return Field.isInstance(clause) && Operator.isGTE(clause.operator);\n  },\n  isLT: function isLT(match) {\n    return match === Operator.LT;\n  },\n  isLTClause: function isLTClause(clause) {\n    return Field.isInstance(clause) && Operator.isLT(clause.operator);\n  },\n  isLTE: function isLTE(match) {\n    return match === Operator.LTE;\n  },\n  isLTEClause: function isLTEClause(clause) {\n    return Field.isInstance(clause) && Operator.isLTE(clause.operator);\n  }\n});\nvar Term = Object.freeze({\n  TYPE: 'term',\n  isInstance: function isInstance(clause) {\n    return clause.type === Term.TYPE;\n  },\n  must: function must(value) {\n    return {\n      type: Term.TYPE,\n      value: value,\n      match: Match.MUST\n    };\n  },\n  mustNot: function mustNot(value) {\n    return {\n      type: Term.TYPE,\n      value: value,\n      match: Match.MUST_NOT\n    };\n  }\n});\nvar Group = Object.freeze({\n  TYPE: 'group',\n  isInstance: function isInstance(clause) {\n    return clause.type === Group.TYPE;\n  },\n  must: function must(value) {\n    return {\n      type: Group.TYPE,\n      value: value,\n      match: Match.MUST\n    };\n  },\n  mustNot: function mustNot(value) {\n    return {\n      type: Group.TYPE,\n      value: value,\n      match: Match.MUST_NOT\n    };\n  }\n});\nvar Field = Object.freeze({\n  TYPE: 'field',\n  isInstance: function isInstance(clause) {\n    return clause.type === Field.TYPE;\n  },\n  must: {\n    eq: function eq(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.EQ\n      };\n    },\n    exact: function exact(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.EXACT\n      };\n    },\n    gt: function gt(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.GT\n      };\n    },\n    gte: function gte(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.GTE\n      };\n    },\n    lt: function lt(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.LT\n      };\n    },\n    lte: function lte(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.LTE\n      };\n    }\n  },\n  mustNot: {\n    eq: function eq(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.EQ\n      };\n    },\n    exact: function exact(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.EXACT\n      };\n    },\n    gt: function gt(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.GT\n      };\n    },\n    gte: function gte(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.GTE\n      };\n    },\n    lt: function lt(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.LT\n      };\n    },\n    lte: function lte(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.LTE\n      };\n    }\n  }\n});\nvar Is = Object.freeze({\n  TYPE: 'is',\n  isInstance: function isInstance(clause) {\n    return clause.type === Is.TYPE;\n  },\n  must: function must(flag) {\n    return {\n      type: Is.TYPE,\n      flag: flag,\n      match: Match.MUST\n    };\n  },\n  mustNot: function mustNot(flag) {\n    return {\n      type: Is.TYPE,\n      flag: flag,\n      match: Match.MUST_NOT\n    };\n  }\n});\n\nvar valuesEqual = function valuesEqual(v1, v2) {\n  if (isDateValue(v1)) {\n    return dateValuesEqual(v1, v2);\n  }\n\n  return v1 === v2;\n};\n\nvar arrayIncludesValue = function arrayIncludesValue(array, value) {\n  return array.some(function (item) {\n    return valuesEqual(item, value);\n  });\n};\n/**\n * The AST structure is an array of clauses. There are 3 types of clauses that are supported:\n *\n * :term:\n * Holds a VALUE and an OCCUR. The OCCUR indicates whether the value must match or must not match. Default\n * clauses are not associated with any specific field - when executing the search, one can specify what are\n * the default fields that the default clauses will be matched against.\n *\n * :field:\n * Like the `term` clause, holds a VALUE and an MATCH, but this clause also specifies the field that the\n * value will be matched against.\n *\n * :is:\n * Holds a FLAG and indicates whether this flag must be applied or must not be applied. Typically this clause\n * matches against boolean values of a record (e.g. \"is:online\", \"is:internal\", \"is:on\", etc..)\n *\n * This AST is immutable - every \"mutating\" operation returns a newly mutated AST.\n */\n\n\nexport var _AST =\n/*#__PURE__*/\nfunction () {\n  _createClass(_AST, null, [{\n    key: \"create\",\n    value: function create(clauses) {\n      return new _AST(clauses);\n    }\n  }]);\n\n  function _AST() {\n    var _this = this;\n\n    var clauses = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    _classCallCheck(this, _AST);\n\n    _defineProperty(this, \"_clauses\", void 0);\n\n    _defineProperty(this, \"_indexedClauses\", void 0);\n\n    this._clauses = clauses;\n    this._indexedClauses = {\n      field: {},\n      is: {},\n      term: [],\n      group: []\n    };\n    clauses.forEach(function (clause) {\n      switch (clause.type) {\n        case Field.TYPE:\n          if (!_this._indexedClauses.field[clause.field]) {\n            _this._indexedClauses.field[clause.field] = [];\n          }\n\n          _this._indexedClauses.field[clause.field].push(clause);\n\n          break;\n\n        case Is.TYPE:\n          _this._indexedClauses.is[clause.flag] = clause;\n          break;\n\n        case Term.TYPE:\n          _this._indexedClauses.term.push(clause);\n\n          break;\n\n        case Group.TYPE:\n          _this._indexedClauses.group.push(clause);\n\n          break;\n\n        default:\n          // @ts-ignore TS knows we have exhausted the match\n          throw new Error(\"Unknown query clause type [\".concat(clause.type, \"]\"));\n      }\n    });\n  }\n\n  _createClass(_AST, [{\n    key: \"getTermClauses\",\n    value: function getTermClauses() {\n      return this._indexedClauses.term;\n    }\n  }, {\n    key: \"getTermClause\",\n    value: function getTermClause(value) {\n      var clauses = this.getTermClauses();\n      return clauses.find(function (clause) {\n        return valuesEqual(clause.value, value);\n      });\n    }\n  }, {\n    key: \"getFieldNames\",\n    value: function getFieldNames() {\n      return Object.keys(this._indexedClauses.field);\n    }\n  }, {\n    key: \"getFieldClauses\",\n    value: function getFieldClauses(field) {\n      return field ? this._indexedClauses.field[field] : this._clauses.filter(Field.isInstance);\n    }\n  }, {\n    key: \"getFieldClause\",\n    value: function getFieldClause(field, predicate) {\n      var clauses = this.getFieldClauses(field);\n\n      if (clauses) {\n        return clauses.find(predicate);\n      }\n    }\n  }, {\n    key: \"hasOrFieldClause\",\n    value: function hasOrFieldClause(field, value) {\n      var clause = this.getFieldClause(field, function (clause) {\n        return isArray(clause.value);\n      });\n\n      if (!clause) {\n        return false;\n      } // We can apply this type cast due to the `isArray` filter above\n\n\n      return isNil(value) || arrayIncludesValue(clause.value, value);\n    }\n  }, {\n    key: \"getOrFieldClause\",\n    value: function getOrFieldClause(field, value) {\n      return this.getFieldClause(field, function (clause) {\n        return isArray(clause.value) && (isNil(value) || arrayIncludesValue(clause.value, value));\n      });\n    }\n  }, {\n    key: \"addOrFieldValue\",\n    value: function addOrFieldValue(field, value) {\n      var must = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var operator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Operator.EQ;\n      var existingClause = this.getOrFieldClause(field);\n\n      if (!existingClause) {\n        var newClause = must ? Field.must[operator](field, [value]) : Field.mustNot[operator](field, [value]);\n        return new _AST([].concat(_toConsumableArray(this._clauses), [newClause]));\n      }\n\n      var clauses = this._clauses.map(function (clause) {\n        if (clause === existingClause) {\n          clause.value.push(value);\n        }\n\n        return clause;\n      });\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"removeOrFieldValue\",\n    value: function removeOrFieldValue(field, value) {\n      var existingClause = this.getOrFieldClause(field, value);\n\n      if (!existingClause) {\n        return new _AST(_toConsumableArray(this._clauses));\n      }\n\n      var clauses = this._clauses.reduce(function (clauses, clause) {\n        if (clause !== existingClause) {\n          clauses.push(clause);\n          return clauses;\n        }\n\n        var filteredValue = clause.value.filter(function (val) {\n          return !valuesEqual(val, value);\n        });\n\n        if (filteredValue.length === 0) {\n          return clauses;\n        }\n\n        clauses.push(_objectSpread({}, clause, {\n          value: filteredValue\n        }));\n        return clauses;\n      }, []);\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"removeOrFieldClauses\",\n    value: function removeOrFieldClauses(field) {\n      var clauses = this._clauses.filter(function (clause) {\n        return !Field.isInstance(clause) || clause.field !== field || !isArray(clause.value);\n      });\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"hasSimpleFieldClause\",\n    value: function hasSimpleFieldClause(field, value) {\n      var clause = this.getFieldClause(field, function (clause) {\n        return !isArray(clause.value);\n      });\n\n      if (!clause) {\n        return false;\n      }\n\n      return isNil(value) || valuesEqual(clause.value, value);\n    }\n  }, {\n    key: \"getSimpleFieldClause\",\n    value: function getSimpleFieldClause(field, value) {\n      return this.getFieldClause(field, function (clause) {\n        return !isArray(clause.value) && (isNil(value) || valuesEqual(clause.value, value));\n      });\n    }\n  }, {\n    key: \"addSimpleFieldValue\",\n    value: function addSimpleFieldValue(field, value) {\n      var must = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var operator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Operator.EQ;\n      var clause = must ? Field.must[operator](field, value) : Field.mustNot[operator](field, value);\n      return this.addClause(clause);\n    }\n  }, {\n    key: \"removeSimpleFieldValue\",\n    value: function removeSimpleFieldValue(field, value) {\n      var existingClause = this.getSimpleFieldClause(field, value);\n\n      if (!existingClause) {\n        return new _AST(_toConsumableArray(this._clauses));\n      }\n\n      var clauses = this._clauses.filter(function (clause) {\n        return clause !== existingClause;\n      });\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"removeSimpleFieldClauses\",\n    value: function removeSimpleFieldClauses(field) {\n      var clauses = this._clauses.filter(function (clause) {\n        return !Field.isInstance(clause) || clause.field !== field || isArray(clause.value);\n      });\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"getIsClauses\",\n    value: function getIsClauses() {\n      return Object.values(this._indexedClauses.is);\n    }\n  }, {\n    key: \"getIsClause\",\n    value: function getIsClause(flag) {\n      return this._indexedClauses.is[flag];\n    }\n  }, {\n    key: \"removeIsClause\",\n    value: function removeIsClause(flag) {\n      return new _AST(this._clauses.filter(function (clause) {\n        return !Is.isInstance(clause) || clause.flag !== flag;\n      }));\n    }\n  }, {\n    key: \"getGroupClauses\",\n    value: function getGroupClauses() {\n      return Object.values(this._indexedClauses.group);\n    }\n    /**\n     * Creates and returns a new AST with the given clause added to the current clauses. If\n     * the current clauses already include a similar clause, it will be (in-place) replaced by\n     * the given clause. Whether a clause is similar to the given one depends on the type of the clause.\n     * Two clauses are similar if:\n     *\n     * - they are both of the same type\n     * - if they are `default` clauses, they must have the same value\n     * - if they are `term` clauses, they must have the same fields and values\n     * - if they are `is` clauses, they must have the same flags\n     *\n     * The reasoning behind not including the `match` attributes of the clauses in the rules above, stems\n     * in the fact that the AST clauses are ANDed, and having two similar clauses with two different\n     * match attributes creates a logically contradicted AST (e.g. what does it mean to\n     * \"(must have x) AND (must not have x)\"?)\n     *\n     * note:  in-place replacement means the given clause will be placed in the same position as the one it\n     *        replaced\n     */\n\n  }, {\n    key: \"addClause\",\n    value: function addClause(newClause) {\n      var added = false;\n\n      var newClauses = this._clauses.reduce(function (clauses, clause) {\n        if (newClause.type !== clause.type) {\n          clauses.push(clause);\n          return clauses;\n        }\n\n        switch (newClause.type) {\n          case Term.TYPE:\n            if (newClause.value !== clause.value) {\n              clauses.push(clause);\n              return clauses;\n            }\n\n            break;\n\n          case Field.TYPE:\n            if (newClause.field !== clause.field || newClause.value !== clause.value) {\n              clauses.push(clause);\n              return clauses;\n            }\n\n            break;\n\n          case Is.TYPE:\n            if (newClause.flag !== clause.flag) {\n              clauses.push(clause);\n              return clauses;\n            }\n\n            break;\n\n          default:\n            throw new Error(\"unknown clause type [\".concat(newClause.type, \"]\"));\n        }\n\n        added = true;\n        clauses.push(newClause);\n        return clauses;\n      }, []);\n\n      if (!added) {\n        newClauses.push(newClause);\n      }\n\n      return new _AST(newClauses);\n    }\n  }, {\n    key: \"clauses\",\n    get: function get() {\n      return this._clauses;\n    }\n  }]);\n\n  return _AST;\n}();\nexport var AST = Object.freeze({\n  Match: Match,\n  Operator: Operator,\n  Term: Term,\n  Group: Group,\n  Field: Field,\n  Is: Is,\n  create: function create(clauses) {\n    return new _AST(clauses);\n  }\n});"]},"metadata":{},"sourceType":"module"}