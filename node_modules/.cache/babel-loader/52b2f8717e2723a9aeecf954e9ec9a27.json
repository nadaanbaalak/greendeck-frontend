{"ast":null,"code":"var _nameToOperatorMap;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\nimport { get } from '../../../services/objects';\nimport { isString, isArray } from '../../../services/predicate';\nimport { eq, exact, gt, gte, lt, lte } from './operators';\nimport { AST } from './ast';\nvar EXPLAIN_FIELD = '__explain';\nvar nameToOperatorMap = (_nameToOperatorMap = {}, _defineProperty(_nameToOperatorMap, AST.Operator.EQ, eq), _defineProperty(_nameToOperatorMap, AST.Operator.EXACT, exact), _defineProperty(_nameToOperatorMap, AST.Operator.GT, gt), _defineProperty(_nameToOperatorMap, AST.Operator.GTE, gte), _defineProperty(_nameToOperatorMap, AST.Operator.LT, lt), _defineProperty(_nameToOperatorMap, AST.Operator.LTE, lte), _nameToOperatorMap);\n\nvar defaultIsClauseMatcher = function defaultIsClauseMatcher(item, clause, explain) {\n  var type = clause.type,\n      flag = clause.flag,\n      match = clause.match;\n  var value = get(item, clause.flag);\n  var must = AST.Match.isMustClause(clause);\n  var hit = !!value === must;\n\n  if (explain && hit) {\n    explain.push({\n      hit: hit,\n      type: type,\n      flag: flag,\n      match: match\n    });\n  }\n\n  return hit;\n};\n\nvar fieldClauseMatcher = function fieldClauseMatcher(item, field) {\n  var clauses = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var explain = arguments.length > 3 ? arguments[3] : undefined;\n  return clauses.every(function (clause) {\n    var type = clause.type,\n        value = clause.value,\n        match = clause.match;\n    var operator = nameToOperatorMap[clause.operator];\n\n    if (!operator) {\n      // unknown matcher\n      return true;\n    }\n\n    if (!AST.Match.isMust(match)) {\n      operator = function operator(value, token) {\n        return !nameToOperatorMap[clause.operator](value, token);\n      };\n    }\n\n    var itemValue = get(item, field);\n    var hit = isArray(value) ? value.some(function (v) {\n      return operator(itemValue, v);\n    }) : operator(itemValue, value);\n\n    if (explain && hit) {\n      explain.push({\n        hit: hit,\n        type: type,\n        field: field,\n        value: value,\n        match: match,\n        operator: operator\n      });\n    }\n\n    return hit;\n  });\n}; // You might think that we could specify `item: T` here and do something\n// with `keyof`, but that wouldn't work with `nested.field.name`\n\n\nvar extractStringFieldsFromItem = function extractStringFieldsFromItem(item) {\n  return Object.keys(item).reduce(function (fields, key) {\n    if (isString(item[key])) {\n      fields.push(key);\n    }\n\n    return fields;\n  }, []);\n};\n\nvar termClauseMatcher = function termClauseMatcher(item, fields) {\n  var clauses = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var explain = arguments.length > 3 ? arguments[3] : undefined;\n  var searchableFields = fields || extractStringFieldsFromItem(item);\n  return clauses.every(function (clause) {\n    var type = clause.type,\n        value = clause.value,\n        match = clause.match;\n    var isMustClause = AST.Match.isMustClause(clause);\n    var equals = nameToOperatorMap[AST.Operator.EQ];\n    var containsMatches = searchableFields.some(function (field) {\n      var itemValue = get(item, field);\n      var isMatch = equals(itemValue, value);\n\n      if (explain) {\n        // If testing for the presence of a term, then we record a match as a match.\n        // If testing for the absence of a term, then we invert this logic: we record a\n        // non-match as a match.\n        var hit = isMustClause && isMatch || !isMustClause && !isMatch;\n\n        if (hit) {\n          explain.push({\n            hit: hit,\n            type: type,\n            field: field,\n            match: match,\n            value: value\n          });\n        }\n      }\n\n      return isMatch;\n    });\n\n    if (isMustClause) {\n      // If we're testing for the presence of a term, then we only need 1 field to match.\n      return containsMatches;\n    } // If we're testing for the absence of a term, we can't have any matching fields at all.\n\n\n    return !containsMatches;\n  });\n};\n\nexport var createFilter = function createFilter(ast, defaultFields) {\n  var isClauseMatcher = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultIsClauseMatcher;\n  var explain = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false; // Return items which pass ALL conditions: matches the terms entered, the specified field values,\n  // and the specified \"is\" clauses.\n\n  return function (item) {\n    var explainLines = explain ? [] : undefined;\n\n    if (explainLines) {\n      // @ts-ignore technically, we could require T to extend `{ __explain?: Explain[] }` but that seems\n      // like a ridiculous requirement on the caller.\n      item[EXPLAIN_FIELD] = explainLines;\n    }\n\n    var termClauses = ast.getTermClauses();\n    var fields = ast.getFieldNames();\n    var isClauses = ast.getIsClauses();\n    var groupClauses = ast.getGroupClauses();\n    var isTermMatch = termClauseMatcher(item, defaultFields, termClauses, explainLines);\n\n    if (!isTermMatch) {\n      return false;\n    }\n\n    var isFieldsMatch = fields.every(function (field) {\n      return fieldClauseMatcher(item, field, ast.getFieldClauses(field), explainLines);\n    });\n\n    if (!isFieldsMatch) {\n      return false;\n    }\n\n    var isIsMatch = isClauses.every(function (clause) {\n      return isClauseMatcher(item, clause, explainLines);\n    });\n\n    if (!isIsMatch) {\n      return false;\n    }\n\n    var isGroupMatch = groupClauses.every(function (clause) {\n      var matchesGroup = clause.value.some(function (clause) {\n        if (AST.Term.isInstance(clause)) {\n          return termClauseMatcher(item, defaultFields, [clause], explainLines);\n        }\n\n        if (AST.Field.isInstance(clause)) {\n          return fieldClauseMatcher(item, clause.field, [clause], explainLines);\n        }\n\n        if (AST.Is.isInstance(clause)) {\n          return isClauseMatcher(item, clause, explainLines);\n        }\n\n        throw new Error(\"Unknown query clause type in group, [\".concat(clause.type, \"]\"));\n      });\n      return AST.Match.isMustClause(clause) ? matchesGroup : !matchesGroup;\n    });\n    return isGroupMatch;\n  };\n};\nexport function executeAst(ast, items) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var isClauseMatcher = options.isClauseMatcher,\n      defaultFields = options.defaultFields,\n      explain = options.explain;\n  var filter = createFilter(ast, defaultFields, isClauseMatcher, explain);\n  return items.filter(filter);\n}","map":{"version":3,"sources":["/home/nadaanbaalak/greendeck/client/node_modules/@elastic/eui/es/components/search_bar/query/execute_ast.js"],"names":["_nameToOperatorMap","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","get","isString","isArray","eq","exact","gt","gte","lt","lte","AST","EXPLAIN_FIELD","nameToOperatorMap","Operator","EQ","EXACT","GT","GTE","LT","LTE","defaultIsClauseMatcher","item","clause","explain","type","flag","match","must","Match","isMustClause","hit","push","fieldClauseMatcher","field","clauses","arguments","length","undefined","every","operator","isMust","token","itemValue","some","v","extractStringFieldsFromItem","keys","reduce","fields","termClauseMatcher","searchableFields","equals","containsMatches","isMatch","createFilter","ast","defaultFields","isClauseMatcher","explainLines","termClauses","getTermClauses","getFieldNames","isClauses","getIsClauses","groupClauses","getGroupClauses","isTermMatch","isFieldsMatch","getFieldClauses","isIsMatch","isGroupMatch","matchesGroup","Term","isInstance","Field","Is","Error","concat","executeAst","items","options","filter"],"mappings":"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","sourcesContent":["var _nameToOperatorMap;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { get } from '../../../services/objects';\nimport { isString, isArray } from '../../../services/predicate';\nimport { eq, exact, gt, gte, lt, lte } from './operators';\nimport { AST } from './ast';\nvar EXPLAIN_FIELD = '__explain';\nvar nameToOperatorMap = (_nameToOperatorMap = {}, _defineProperty(_nameToOperatorMap, AST.Operator.EQ, eq), _defineProperty(_nameToOperatorMap, AST.Operator.EXACT, exact), _defineProperty(_nameToOperatorMap, AST.Operator.GT, gt), _defineProperty(_nameToOperatorMap, AST.Operator.GTE, gte), _defineProperty(_nameToOperatorMap, AST.Operator.LT, lt), _defineProperty(_nameToOperatorMap, AST.Operator.LTE, lte), _nameToOperatorMap);\n\nvar defaultIsClauseMatcher = function defaultIsClauseMatcher(item, clause, explain) {\n  var type = clause.type,\n      flag = clause.flag,\n      match = clause.match;\n  var value = get(item, clause.flag);\n  var must = AST.Match.isMustClause(clause);\n  var hit = !!value === must;\n\n  if (explain && hit) {\n    explain.push({\n      hit: hit,\n      type: type,\n      flag: flag,\n      match: match\n    });\n  }\n\n  return hit;\n};\n\nvar fieldClauseMatcher = function fieldClauseMatcher(item, field) {\n  var clauses = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var explain = arguments.length > 3 ? arguments[3] : undefined;\n  return clauses.every(function (clause) {\n    var type = clause.type,\n        value = clause.value,\n        match = clause.match;\n    var operator = nameToOperatorMap[clause.operator];\n\n    if (!operator) {\n      // unknown matcher\n      return true;\n    }\n\n    if (!AST.Match.isMust(match)) {\n      operator = function operator(value, token) {\n        return !nameToOperatorMap[clause.operator](value, token);\n      };\n    }\n\n    var itemValue = get(item, field);\n    var hit = isArray(value) ? value.some(function (v) {\n      return operator(itemValue, v);\n    }) : operator(itemValue, value);\n\n    if (explain && hit) {\n      explain.push({\n        hit: hit,\n        type: type,\n        field: field,\n        value: value,\n        match: match,\n        operator: operator\n      });\n    }\n\n    return hit;\n  });\n}; // You might think that we could specify `item: T` here and do something\n// with `keyof`, but that wouldn't work with `nested.field.name`\n\n\nvar extractStringFieldsFromItem = function extractStringFieldsFromItem(item) {\n  return Object.keys(item).reduce(function (fields, key) {\n    if (isString(item[key])) {\n      fields.push(key);\n    }\n\n    return fields;\n  }, []);\n};\n\nvar termClauseMatcher = function termClauseMatcher(item, fields) {\n  var clauses = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var explain = arguments.length > 3 ? arguments[3] : undefined;\n  var searchableFields = fields || extractStringFieldsFromItem(item);\n  return clauses.every(function (clause) {\n    var type = clause.type,\n        value = clause.value,\n        match = clause.match;\n    var isMustClause = AST.Match.isMustClause(clause);\n    var equals = nameToOperatorMap[AST.Operator.EQ];\n    var containsMatches = searchableFields.some(function (field) {\n      var itemValue = get(item, field);\n      var isMatch = equals(itemValue, value);\n\n      if (explain) {\n        // If testing for the presence of a term, then we record a match as a match.\n        // If testing for the absence of a term, then we invert this logic: we record a\n        // non-match as a match.\n        var hit = isMustClause && isMatch || !isMustClause && !isMatch;\n\n        if (hit) {\n          explain.push({\n            hit: hit,\n            type: type,\n            field: field,\n            match: match,\n            value: value\n          });\n        }\n      }\n\n      return isMatch;\n    });\n\n    if (isMustClause) {\n      // If we're testing for the presence of a term, then we only need 1 field to match.\n      return containsMatches;\n    } // If we're testing for the absence of a term, we can't have any matching fields at all.\n\n\n    return !containsMatches;\n  });\n};\n\nexport var createFilter = function createFilter(ast, defaultFields) {\n  var isClauseMatcher = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultIsClauseMatcher;\n  var explain = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  // Return items which pass ALL conditions: matches the terms entered, the specified field values,\n  // and the specified \"is\" clauses.\n  return function (item) {\n    var explainLines = explain ? [] : undefined;\n\n    if (explainLines) {\n      // @ts-ignore technically, we could require T to extend `{ __explain?: Explain[] }` but that seems\n      // like a ridiculous requirement on the caller.\n      item[EXPLAIN_FIELD] = explainLines;\n    }\n\n    var termClauses = ast.getTermClauses();\n    var fields = ast.getFieldNames();\n    var isClauses = ast.getIsClauses();\n    var groupClauses = ast.getGroupClauses();\n    var isTermMatch = termClauseMatcher(item, defaultFields, termClauses, explainLines);\n\n    if (!isTermMatch) {\n      return false;\n    }\n\n    var isFieldsMatch = fields.every(function (field) {\n      return fieldClauseMatcher(item, field, ast.getFieldClauses(field), explainLines);\n    });\n\n    if (!isFieldsMatch) {\n      return false;\n    }\n\n    var isIsMatch = isClauses.every(function (clause) {\n      return isClauseMatcher(item, clause, explainLines);\n    });\n\n    if (!isIsMatch) {\n      return false;\n    }\n\n    var isGroupMatch = groupClauses.every(function (clause) {\n      var matchesGroup = clause.value.some(function (clause) {\n        if (AST.Term.isInstance(clause)) {\n          return termClauseMatcher(item, defaultFields, [clause], explainLines);\n        }\n\n        if (AST.Field.isInstance(clause)) {\n          return fieldClauseMatcher(item, clause.field, [clause], explainLines);\n        }\n\n        if (AST.Is.isInstance(clause)) {\n          return isClauseMatcher(item, clause, explainLines);\n        }\n\n        throw new Error(\"Unknown query clause type in group, [\".concat(clause.type, \"]\"));\n      });\n      return AST.Match.isMustClause(clause) ? matchesGroup : !matchesGroup;\n    });\n    return isGroupMatch;\n  };\n};\nexport function executeAst(ast, items) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var isClauseMatcher = options.isClauseMatcher,\n      defaultFields = options.defaultFields,\n      explain = options.explain;\n  var filter = createFilter(ast, defaultFields, isClauseMatcher, explain);\n  return items.filter(filter);\n}"]},"metadata":{},"sourceType":"module"}