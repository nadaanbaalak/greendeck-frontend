{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getDurationAndPerformOnFrame = exports.performOnFrame = exports.getWaitDuration = exports.getTransitionTimings = void 0;\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nvar GROUP_NUMERIC = /^([\\d.]+)(s|ms)/;\n\nfunction getMilliseconds(value, unit) {\n  // Given the regex match and capture groups, we can assume `unit` to be either 's' or 'ms'\n  var multiplier = unit === 's' ? 1000 : 1;\n  return parseFloat(value) * multiplier;\n} // Find CSS `transition-duration` and `transition-delay` intervals\n// and return the value of each computed property in 'ms'\n\n\nvar getTransitionTimings = function getTransitionTimings(element) {\n  var computedStyle = window.getComputedStyle(element);\n  var computedDuration = computedStyle.getPropertyValue('transition-duration');\n  var durationMatchArray = computedDuration.match(GROUP_NUMERIC);\n  var durationMatch = durationMatchArray ? getMilliseconds(durationMatchArray[1], durationMatchArray[2]) : 0;\n  var computedDelay = computedStyle.getPropertyValue('transition-delay');\n  var delayMatchArray = computedDelay.match(GROUP_NUMERIC);\n  var delayMatch = delayMatchArray ? getMilliseconds(delayMatchArray[1], delayMatchArray[2]) : 0;\n  return {\n    durationMatch: durationMatch,\n    delayMatch: delayMatch\n  };\n};\n\nexports.getTransitionTimings = getTransitionTimings;\n\nfunction isElementNode(element) {\n  return element.nodeType === document.ELEMENT_NODE;\n} // Uses `getTransitionTimings` to find the total transition time for\n// all elements targeted by a MutationObserver callback\n\n\nvar getWaitDuration = function getWaitDuration(records) {\n  return records.reduce(function (waitDuration, record) {\n    // only check for CSS transition values for ELEMENT nodes\n    if (isElementNode(record.target)) {\n      var _getTransitionTimings = getTransitionTimings(record.target),\n          durationMatch = _getTransitionTimings.durationMatch,\n          delayMatch = _getTransitionTimings.delayMatch;\n\n      waitDuration = Math.max(waitDuration, durationMatch + delayMatch);\n    }\n\n    return waitDuration;\n  }, 0);\n}; // Uses `requestAnimationFrame` to perform a given callback after a specified waiting period\n\n\nexports.getWaitDuration = getWaitDuration;\n\nvar performOnFrame = function performOnFrame(waitDuration, toPerform) {\n  if (waitDuration > 0) {\n    var startTime = Date.now();\n    var endTime = startTime + waitDuration;\n\n    var onFrame = function onFrame() {\n      toPerform();\n\n      if (endTime > Date.now()) {\n        requestAnimationFrame(onFrame);\n      }\n    };\n\n    requestAnimationFrame(onFrame);\n  }\n}; // Convenience method for combining the result of 'getWaitDuration' directly with 'performOnFrame'\n\n\nexports.performOnFrame = performOnFrame;\n\nvar getDurationAndPerformOnFrame = function getDurationAndPerformOnFrame(records, toPerform) {\n  performOnFrame(getWaitDuration(records), toPerform);\n};\n\nexports.getDurationAndPerformOnFrame = getDurationAndPerformOnFrame;","map":{"version":3,"sources":["/home/nadaanbaalak/greendeck/client/node_modules/@elastic/eui/lib/services/transition/transition.js"],"names":["Object","defineProperty","exports","value","getDurationAndPerformOnFrame","performOnFrame","getWaitDuration","getTransitionTimings","GROUP_NUMERIC","getMilliseconds","unit","multiplier","parseFloat","element","computedStyle","window","getComputedStyle","computedDuration","getPropertyValue","durationMatchArray","match","durationMatch","computedDelay","delayMatchArray","delayMatch","isElementNode","nodeType","document","ELEMENT_NODE","records","reduce","waitDuration","record","target","_getTransitionTimings","Math","max","toPerform","startTime","Date","now","endTime","onFrame","requestAnimationFrame"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getDurationAndPerformOnFrame = exports.performOnFrame = exports.getWaitDuration = exports.getTransitionTimings = void 0;\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nvar GROUP_NUMERIC = /^([\\d.]+)(s|ms)/;\n\nfunction getMilliseconds(value, unit) {\n  // Given the regex match and capture groups, we can assume `unit` to be either 's' or 'ms'\n  var multiplier = unit === 's' ? 1000 : 1;\n  return parseFloat(value) * multiplier;\n} // Find CSS `transition-duration` and `transition-delay` intervals\n// and return the value of each computed property in 'ms'\n\n\nvar getTransitionTimings = function getTransitionTimings(element) {\n  var computedStyle = window.getComputedStyle(element);\n  var computedDuration = computedStyle.getPropertyValue('transition-duration');\n  var durationMatchArray = computedDuration.match(GROUP_NUMERIC);\n  var durationMatch = durationMatchArray ? getMilliseconds(durationMatchArray[1], durationMatchArray[2]) : 0;\n  var computedDelay = computedStyle.getPropertyValue('transition-delay');\n  var delayMatchArray = computedDelay.match(GROUP_NUMERIC);\n  var delayMatch = delayMatchArray ? getMilliseconds(delayMatchArray[1], delayMatchArray[2]) : 0;\n  return {\n    durationMatch: durationMatch,\n    delayMatch: delayMatch\n  };\n};\n\nexports.getTransitionTimings = getTransitionTimings;\n\nfunction isElementNode(element) {\n  return element.nodeType === document.ELEMENT_NODE;\n} // Uses `getTransitionTimings` to find the total transition time for\n// all elements targeted by a MutationObserver callback\n\n\nvar getWaitDuration = function getWaitDuration(records) {\n  return records.reduce(function (waitDuration, record) {\n    // only check for CSS transition values for ELEMENT nodes\n    if (isElementNode(record.target)) {\n      var _getTransitionTimings = getTransitionTimings(record.target),\n          durationMatch = _getTransitionTimings.durationMatch,\n          delayMatch = _getTransitionTimings.delayMatch;\n\n      waitDuration = Math.max(waitDuration, durationMatch + delayMatch);\n    }\n\n    return waitDuration;\n  }, 0);\n}; // Uses `requestAnimationFrame` to perform a given callback after a specified waiting period\n\n\nexports.getWaitDuration = getWaitDuration;\n\nvar performOnFrame = function performOnFrame(waitDuration, toPerform) {\n  if (waitDuration > 0) {\n    var startTime = Date.now();\n    var endTime = startTime + waitDuration;\n\n    var onFrame = function onFrame() {\n      toPerform();\n\n      if (endTime > Date.now()) {\n        requestAnimationFrame(onFrame);\n      }\n    };\n\n    requestAnimationFrame(onFrame);\n  }\n}; // Convenience method for combining the result of 'getWaitDuration' directly with 'performOnFrame'\n\n\nexports.performOnFrame = performOnFrame;\n\nvar getDurationAndPerformOnFrame = function getDurationAndPerformOnFrame(records, toPerform) {\n  performOnFrame(getWaitDuration(records), toPerform);\n};\n\nexports.getDurationAndPerformOnFrame = getDurationAndPerformOnFrame;"]},"metadata":{},"sourceType":"script"}