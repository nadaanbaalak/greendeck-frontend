{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\nexport var POSITIONS = ['top', 'right', 'bottom', 'left'];\nvar relatedDimension = {\n  top: 'height',\n  right: 'width',\n  bottom: 'height',\n  left: 'width'\n};\nvar dimensionPositionAttribute = {\n  height: 'top',\n  width: 'left'\n};\nvar positionComplements = {\n  top: 'bottom',\n  right: 'left',\n  bottom: 'top',\n  left: 'right'\n}; // always resolving to top/left is taken advantage of by knowing they are the\n// minimum edges of the bounding box\n\nvar positionSubstitutes = {\n  top: 'left',\n  right: 'top',\n  bottom: 'left',\n  left: 'top'\n};\n/**\n * Calculates the absolute positioning (relative to document.body) to place a popover element\n *\n * @param anchor {HTMLElement} Element to anchor the popover to\n * @param popover {HTMLElement} Element containing the popover content\n * @param position {string} Position the user wants. One of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param [forcePosition] {boolean} If true, use only the provided `position` value and don't try any other position\n * @param [align] {string} Cross-axis alignment. One of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param [buffer=16] {number} Minimum distance between the popover and the bounding container\n * @param [offset=0] {number} Distance between the popover and the anchor\n * @param [allowCrossAxis=true] {boolean} Whether to allow the popover to be positioned on the cross-axis\n * @param [container] {HTMLElement} Element the popover must be constrained to fit within\n * @param [arrowConfig] {{arrowWidth: number, arrowBuffer: number}} If\n *  present, describes the size & constraints for an arrow element, and the\n *  function return value will include an `arrow` param with position details\n *\n * @returns {FindPopoverPositionResult} absolute page coordinates for the\n * popover, and the placement's relation to the anchor or undefined\n * there's no room.\n */\n\nexport function findPopoverPosition(_ref) {\n  var anchor = _ref.anchor,\n      popover = _ref.popover,\n      align = _ref.align,\n      position = _ref.position,\n      forcePosition = _ref.forcePosition,\n      _ref$buffer = _ref.buffer,\n      buffer = _ref$buffer === void 0 ? 16 : _ref$buffer,\n      _ref$offset = _ref.offset,\n      offset = _ref$offset === void 0 ? 0 : _ref$offset,\n      _ref$allowCrossAxis = _ref.allowCrossAxis,\n      allowCrossAxis = _ref$allowCrossAxis === void 0 ? true : _ref$allowCrossAxis,\n      container = _ref.container,\n      arrowConfig = _ref.arrowConfig,\n      returnBoundingBox = _ref.returnBoundingBox; // find the screen-relative bounding boxes of the anchor, popover, and container\n\n  var anchorBoundingBox = getElementBoundingBox(anchor);\n  var popoverBoundingBox = getElementBoundingBox(popover); // calculate the window's bounds\n  // window.(innerWidth|innerHeight) do not account for scrollbars\n  // so prefer the clientWidth/clientHeight of the DOM if available\n\n  var documentWidth = document.documentElement.clientWidth || window.innerWidth;\n  var documentHeight = document.documentElement.clientHeight || window.innerHeight;\n  var windowBoundingBox = {\n    top: 0,\n    right: documentWidth,\n    bottom: documentHeight,\n    left: 0,\n    height: documentHeight,\n    width: documentWidth\n  }; // if no container element is given fall back to using the window viewport\n\n  var containerBoundingBox = container ? getElementBoundingBox(container) : windowBoundingBox;\n  /**\n   * `position` was specified by the function caller and is a strong hint\n   * as to the preferred location of the popover relative to the anchor.\n   * However, we strongly prefer showing all of the popover content within\n   * the window+container boundary and will iterate over the four\n   * possible sides until a perfect fit is located. If none of the locations\n   * fully contain popover, the location with the best fit is selected.\n   *\n   * This approach first checks the preferred `position`, then its opposite\n   * along the same axis, next a location on the cross-axis, and finally it\n   * tests the remaining position.\n   *\n   * e.g.\n   * if position = \"top\" the order is top, bottom, left right\n   * if position = \"right\" the order is right, left, top, bottom\n   */\n  // Try the user-desired position first.\n\n  var iterationPositions = [position]; // keep user-defined alignment in the original positions.\n\n  var iterationAlignments = [align];\n\n  if (forcePosition !== true) {\n    iterationPositions.push(positionComplements[position]); // Try the complementary position.\n\n    iterationAlignments.push(align); // keep user-defined alignment in the complementary position.\n\n    if (allowCrossAxis) {\n      iterationPositions.push(positionSubstitutes[position], // Switch to the cross axis.\n      positionComplements[positionSubstitutes[position]] // Try the complementary position on the cross axis.\n      );\n      iterationAlignments.push(undefined, undefined); // discard desired alignment on cross-axis\n    }\n  } else {\n    // position is forced, if it conflicts with the alignment then reset align to `null`\n    // e.g. original placement request for `downLeft` is moved to the `left` side, future calls\n    // will position and align `left`, and `leftLeft` is not a valid placement\n    if (position === align || align !== undefined && position === positionComplements[align]) {\n      iterationAlignments[0] = undefined;\n    }\n  }\n\n  var bestFit = undefined;\n  var bestPosition = null;\n\n  for (var idx = 0; idx < iterationPositions.length; idx++) {\n    var iterationPosition = iterationPositions[idx]; // See if we can find a position with a better fit than we've found so far.\n\n    var screenCoordinates = getPopoverScreenCoordinates({\n      position: iterationPosition,\n      align: iterationAlignments[idx],\n      anchorBoundingBox: anchorBoundingBox,\n      popoverBoundingBox: popoverBoundingBox,\n      windowBoundingBox: windowBoundingBox,\n      containerBoundingBox: containerBoundingBox,\n      offset: offset,\n      buffer: buffer,\n      arrowConfig: arrowConfig\n    });\n\n    if (bestFit === undefined || screenCoordinates.fit > bestFit) {\n      bestFit = screenCoordinates.fit;\n      bestPosition = {\n        fit: screenCoordinates.fit,\n        position: iterationPosition,\n        top: screenCoordinates.top + window.pageYOffset,\n        left: screenCoordinates.left + window.pageXOffset,\n        arrow: screenCoordinates.arrow\n      }; // If we've already found the ideal fit, use that position.\n\n      if (bestFit === 1) {\n        break;\n      }\n    } // If we haven't improved the fit, then continue on and try a new position.\n\n  }\n\n  if (bestPosition == null) {\n    throw new Error('Failed to calculate bestPosition');\n  }\n\n  if (returnBoundingBox) {\n    bestPosition.anchorBoundingBox = anchorBoundingBox;\n  }\n\n  return bestPosition;\n}\n/**\n * Given a target position and the popover's surrounding context, returns either an\n * object with {top, left} screen coordinates or `null` if it's not possible to show\n * content in the target position\n * @param position {string} the target position, one of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param align {string} target alignment on the cross-axis, one of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param anchorBoundingBox {Object} bounding box of the anchor element\n * @param popoverBoundingBox {Object} bounding box of the popover element\n * @param windowBoundingBox {Object} bounding box of the window\n * @param containerBoundingBox {Object} bounding box of the container\n * @param [arrowConfig] {{arrowWidth: number, arrowBuffer: number}} If present, describes the size &\n *  constraints for an arrow element, and the function return value will include an `arrow` param\n *  with position details\n * @param [offset=0] {number} Distance between the popover and the anchor\n * @param [buffer=0] {number} Minimum distance between the popover's\n *  placement and the container edge\n *\n * @returns {GetPopoverScreenCoordinatesResult}\n *  object with top/left coordinates, the popover's relative position to the anchor, and how well the\n *  popover fits in the location (0.0 -> 1.0) coordinates and the popover's relative position, if\n *  there is no room in this placement then null\n */\n\nexport function getPopoverScreenCoordinates(_ref2) {\n  var _popoverPlacement, _ref3;\n\n  var position = _ref2.position,\n      align = _ref2.align,\n      anchorBoundingBox = _ref2.anchorBoundingBox,\n      popoverBoundingBox = _ref2.popoverBoundingBox,\n      windowBoundingBox = _ref2.windowBoundingBox,\n      containerBoundingBox = _ref2.containerBoundingBox,\n      arrowConfig = _ref2.arrowConfig,\n      _ref2$offset = _ref2.offset,\n      offset = _ref2$offset === void 0 ? 0 : _ref2$offset,\n      _ref2$buffer = _ref2.buffer,\n      buffer = _ref2$buffer === void 0 ? 0 : _ref2$buffer;\n  /**\n   * The goal is to find the best way to align the popover content\n   * on the given side of the anchor element. The popover prefers\n   * centering on the anchor but can shift along the cross-axis as needed.\n   *\n   * We return the top/left coordinates that best fit the popover inside\n   * the given boundaries, and also return the `fit` value which indicates\n   * what percentage of the popover is within the bounds.\n   *\n   * e.g. finding a location when position=top\n   * the preferred location is directly over the anchor\n   *\n   *        +----------------------+\n   *        |       popover        |\n   *        +----------------------+\n   *                   v\n   *            +--------------+\n   *            |    anchor    |\n   *            +--------------+\n   *\n   * but if anchor doesn't have much (or any) room on its ride side\n   * the popover will shift to the left\n   *\n   *    +----------------------+\n   *    |       popover        |\n   *    +----------------------+\n   *                   v\n   *            +--------------+\n   *            |    anchor    |\n   *            +--------------+\n   *\n   */\n\n  var crossAxisFirstSide = positionSubstitutes[position]; // \"top\" -> \"left\"\n\n  var crossAxisSecondSide = positionComplements[crossAxisFirstSide]; // \"left\" -> \"right\"\n\n  var crossAxisDimension = relatedDimension[crossAxisFirstSide]; // \"left\" -> \"width\"\n\n  var _getCrossAxisPosition = getCrossAxisPosition({\n    crossAxisFirstSide: crossAxisFirstSide,\n    crossAxisSecondSide: crossAxisSecondSide,\n    crossAxisDimension: crossAxisDimension,\n    position: position,\n    align: align,\n    buffer: buffer,\n    offset: offset,\n    windowBoundingBox: windowBoundingBox,\n    containerBoundingBox: containerBoundingBox,\n    popoverBoundingBox: popoverBoundingBox,\n    anchorBoundingBox: anchorBoundingBox,\n    arrowConfig: arrowConfig\n  }),\n      crossAxisPosition = _getCrossAxisPosition.crossAxisPosition,\n      crossAxisArrowPosition = _getCrossAxisPosition.crossAxisArrowPosition;\n\n  var primaryAxisDimension = relatedDimension[position]; // \"top\" -> \"height\"\n\n  var primaryAxisPositionName = dimensionPositionAttribute[primaryAxisDimension]; // \"height\" -> \"top\"\n\n  var _getPrimaryAxisPositi = getPrimaryAxisPosition({\n    position: position,\n    offset: offset,\n    popoverBoundingBox: popoverBoundingBox,\n    anchorBoundingBox: anchorBoundingBox,\n    arrowConfig: arrowConfig\n  }),\n      primaryAxisPosition = _getPrimaryAxisPositi.primaryAxisPosition,\n      primaryAxisArrowPosition = _getPrimaryAxisPositi.primaryAxisArrowPosition;\n\n  var popoverPlacement = (_popoverPlacement = {}, _defineProperty(_popoverPlacement, crossAxisFirstSide, crossAxisPosition), _defineProperty(_popoverPlacement, primaryAxisPositionName, primaryAxisPosition), _popoverPlacement); // calculate the fit of the popover in this location\n  // fit is in range 0.0 -> 1.0 and is the percentage of the popover which is visible in this location\n\n  var combinedBoundingBox = intersectBoundingBoxes(windowBoundingBox, containerBoundingBox); // shrink the visible bounding box by `buffer`\n  // to compute a fit value\n\n  combinedBoundingBox.top += buffer;\n  combinedBoundingBox.right -= buffer;\n  combinedBoundingBox.bottom -= buffer;\n  combinedBoundingBox.left += buffer;\n  var fit = getVisibleFit({\n    top: popoverPlacement.top,\n    right: popoverPlacement.left + popoverBoundingBox.width,\n    bottom: popoverPlacement.top + popoverBoundingBox.height,\n    left: popoverPlacement.left,\n    width: popoverBoundingBox.width,\n    height: popoverBoundingBox.height\n  }, combinedBoundingBox);\n  var arrow = arrowConfig ? (_ref3 = {}, _defineProperty(_ref3, crossAxisFirstSide, crossAxisArrowPosition - popoverPlacement[crossAxisFirstSide]), _defineProperty(_ref3, primaryAxisPositionName, primaryAxisArrowPosition), _ref3) : undefined;\n  return {\n    fit: fit,\n    top: popoverPlacement.top,\n    left: popoverPlacement.left,\n    arrow: arrow ? {\n      left: arrow.left,\n      top: arrow.top\n    } : undefined\n  };\n}\n\nfunction getCrossAxisPosition(_ref4) {\n  var crossAxisFirstSide = _ref4.crossAxisFirstSide,\n      crossAxisSecondSide = _ref4.crossAxisSecondSide,\n      crossAxisDimension = _ref4.crossAxisDimension,\n      position = _ref4.position,\n      align = _ref4.align,\n      buffer = _ref4.buffer,\n      offset = _ref4.offset,\n      windowBoundingBox = _ref4.windowBoundingBox,\n      containerBoundingBox = _ref4.containerBoundingBox,\n      popoverBoundingBox = _ref4.popoverBoundingBox,\n      anchorBoundingBox = _ref4.anchorBoundingBox,\n      arrowConfig = _ref4.arrowConfig; // how much of the popover overflows past either side of the anchor if its centered\n\n  var popoverSizeOnCrossAxis = popoverBoundingBox[crossAxisDimension];\n  var anchorSizeOnCrossAxis = anchorBoundingBox[crossAxisDimension];\n  var anchorHalfSize = anchorSizeOnCrossAxis / 2; // the popover's original position on the cross-axis is determined by:\n\n  var crossAxisPositionOriginal = anchorBoundingBox[crossAxisFirstSide] + // where the anchor is located\n  anchorHalfSize - // plus half anchor dimension\n  popoverSizeOnCrossAxis / 2; // less half the popover dimension\n  // To fit the content within both the window and container,\n  // compute the smaller of the two spaces along each edge\n\n  var combinedBoundingBox = intersectBoundingBoxes(windowBoundingBox, containerBoundingBox);\n  var availableSpace = getAvailableSpace(anchorBoundingBox, combinedBoundingBox, buffer, offset, position);\n  var minimumSpace = arrowConfig ? arrowConfig.arrowBuffer : 0;\n  var contentOverflowSize = (popoverSizeOnCrossAxis - anchorSizeOnCrossAxis) / 2;\n  var alignAmount = 0;\n  var alignDirection = 1;\n  var amountOfShiftNeeded = 0;\n  var shiftDirection = 1;\n\n  if (align != null) {\n    // no alignment, find how much the container boundary requires the content to shift\n    alignDirection = align === 'top' || align === 'left' ? 1 : -1;\n    alignAmount = contentOverflowSize;\n    var alignedOverflowAmount = contentOverflowSize + alignAmount;\n    var needsShift = alignedOverflowAmount > availableSpace[positionComplements[align]];\n    amountOfShiftNeeded = needsShift ? alignedOverflowAmount - availableSpace[positionComplements[align]] : 0;\n    shiftDirection = -1 * alignDirection;\n  } else {\n    // shifting the popover to one side may yield a better fit\n    var spaceAvailableOnFirstSide = availableSpace[crossAxisFirstSide];\n    var spaceAvailableOnSecondSide = availableSpace[crossAxisSecondSide];\n    var isShiftTowardFirstSide = spaceAvailableOnFirstSide > spaceAvailableOnSecondSide;\n    shiftDirection = isShiftTowardFirstSide ? -1 : 1; // determine which direction has more room and the popover should shift to\n\n    var leastAvailableSpace = Math.min(spaceAvailableOnFirstSide, spaceAvailableOnSecondSide);\n\n    var _needsShift = contentOverflowSize > leastAvailableSpace;\n\n    amountOfShiftNeeded = _needsShift ? contentOverflowSize - leastAvailableSpace : 0;\n  } // shift over the popover if necessary\n\n\n  var shiftAmount = amountOfShiftNeeded * shiftDirection;\n  var crossAxisPosition = crossAxisPositionOriginal + shiftAmount + alignAmount * alignDirection; // if an `arrowConfig` is specified, find where to position the arrow\n\n  var crossAxisArrowPosition;\n\n  if (arrowConfig) {\n    var arrowWidth = arrowConfig.arrowWidth;\n    crossAxisArrowPosition = anchorBoundingBox[crossAxisFirstSide] + anchorHalfSize - arrowWidth / 2; // make sure there's enough buffer around the arrow\n    // by calculating how how much the arrow would need to move\n    // but instead of moving the arrow, shift the popover content\n\n    if (crossAxisArrowPosition < crossAxisPosition + minimumSpace) {\n      // arrow is too close to the minimum side\n      var difference = crossAxisPosition + minimumSpace - crossAxisArrowPosition;\n      crossAxisPosition -= difference;\n    } else if (crossAxisArrowPosition + minimumSpace + arrowWidth > crossAxisPosition + popoverSizeOnCrossAxis) {\n      // arrow is too close to the maximum side\n      var edge = crossAxisPosition + popoverSizeOnCrossAxis;\n\n      var _difference = crossAxisArrowPosition - (edge - minimumSpace - arrowWidth);\n\n      crossAxisPosition += _difference;\n    }\n  }\n\n  return {\n    crossAxisPosition: crossAxisPosition,\n    crossAxisArrowPosition: crossAxisArrowPosition\n  };\n}\n\nfunction getPrimaryAxisPosition(_ref5) {\n  var position = _ref5.position,\n      offset = _ref5.offset,\n      popoverBoundingBox = _ref5.popoverBoundingBox,\n      anchorBoundingBox = _ref5.anchorBoundingBox,\n      arrowConfig = _ref5.arrowConfig; // if positioning to the top or left, the target position decreases\n  // from the anchor's top or left, otherwise the position adds to the anchor's\n\n  var isOffsetDecreasing = position === 'top' || position === 'left';\n  var primaryAxisDimension = relatedDimension[position]; // \"top\" -> \"height\"\n\n  var popoverSizeOnPrimaryAxis = popoverBoundingBox[primaryAxisDimension]; // start at the top or left edge of the anchor element\n\n  var primaryAxisPositionName = dimensionPositionAttribute[primaryAxisDimension]; // \"height\" -> \"top\"\n\n  var anchorEdgeOrigin = anchorBoundingBox[primaryAxisPositionName]; // find the popover position on the primary axis\n\n  var anchorSizeOnPrimaryAxis = anchorBoundingBox[primaryAxisDimension];\n  var primaryAxisOffset = isOffsetDecreasing ? popoverSizeOnPrimaryAxis : anchorSizeOnPrimaryAxis;\n  var contentOffset = (offset + primaryAxisOffset) * (isOffsetDecreasing ? -1 : 1);\n  var primaryAxisPosition = anchorEdgeOrigin + contentOffset;\n  var primaryAxisArrowPosition;\n\n  if (arrowConfig) {\n    primaryAxisArrowPosition = isOffsetDecreasing ? popoverSizeOnPrimaryAxis : 0;\n  }\n\n  return {\n    primaryAxisPosition: primaryAxisPosition,\n    primaryAxisArrowPosition: primaryAxisArrowPosition\n  };\n}\n/**\n * Finds the client pixel coordinate of each edge for the element's bounding box,\n * and the bounding box's width & height\n *\n * @param {HTMLElement} element\n * @returns {{top: number, right: number, bottom: number, left: number, height: number, width: number}}\n */\n\n\nexport function getElementBoundingBox(element) {\n  var rect = element.getBoundingClientRect();\n  return {\n    top: rect.top,\n    right: rect.right,\n    bottom: rect.bottom,\n    left: rect.left,\n    height: rect.height,\n    width: rect.width\n  };\n}\n/**\n * Calculates the available content space between anchor and container\n *\n * @param {Object} anchorBoundingBox Client bounding box of the anchor element\n * @param {Object} containerBoundingBox Client bounding box of the container element\n * @param {number} buffer Minimum distance between the popover and the bounding container\n * @param {number} offset Distance between the popover and the anchor\n * @param {string} offsetSide Side the offset needs to be applied to, one\n *  of [\"top\", \"right\", \"bottom\", \"left\"]\n * @returns {{top: number, right: number, bottom: number, left: number}}\n */\n\nexport function getAvailableSpace(anchorBoundingBox, containerBoundingBox, buffer, offset, offsetSide) {\n  return {\n    top: anchorBoundingBox.top - containerBoundingBox.top - buffer - (offsetSide === 'top' ? offset : 0),\n    right: containerBoundingBox.right - anchorBoundingBox.right - buffer - (offsetSide === 'right' ? offset : 0),\n    bottom: containerBoundingBox.bottom - anchorBoundingBox.bottom - buffer - (offsetSide === 'bottom' ? offset : 0),\n    left: anchorBoundingBox.left - containerBoundingBox.left - buffer - (offsetSide === 'left' ? offset : 0)\n  };\n}\n/**\n * Computes the fit (overlap) of the content within the container, fit is in range 0.0 => 1.0\n * @param contentBoundingBox bounding box of content to calculate fit for\n * @param containerBoundingBox bounding box of container\n * @returns {number}\n */\n\nexport function getVisibleFit(contentBoundingBox, containerBoundingBox) {\n  var intersection = intersectBoundingBoxes(contentBoundingBox, containerBoundingBox);\n\n  if (intersection.left > intersection.right || intersection.top > intersection.top) {\n    // there is no intersection, the boxes are completely separated on at least one axis\n    return 0;\n  }\n\n  var intersectionArea = (intersection.right - intersection.left) * (intersection.bottom - intersection.top);\n  var contentArea = (contentBoundingBox.right - contentBoundingBox.left) * (contentBoundingBox.bottom - contentBoundingBox.top);\n  return intersectionArea / contentArea;\n}\n/**\n * Calculates the intersection space between two bounding boxes\n *\n * @param firstBox\n * @param secondBox\n * @returns {EuiClientRect}\n */\n\nexport function intersectBoundingBoxes(firstBox, secondBox) {\n  var top = Math.max(firstBox.top, secondBox.top);\n  var right = Math.min(firstBox.right, secondBox.right);\n  var bottom = Math.min(firstBox.bottom, secondBox.bottom);\n  var left = Math.max(firstBox.left, secondBox.left);\n  var height = Math.max(bottom - top, 0);\n  var width = Math.max(right - left, 0);\n  return {\n    top: top,\n    right: right,\n    bottom: bottom,\n    left: left,\n    height: height,\n    width: width\n  };\n}\n/**\n * Returns the top-most defined z-index in the element's ancestor hierarchy\n * relative to the `target` element; if no z-index is defined, returns 0\n * @param element {HTMLElement}\n * @param cousin {HTMLElement}\n * @returns {number}\n */\n\nexport function getElementZIndex(element, cousin) {\n  /**\n   * finding the z-index of `element` is not the full story\n   * its the CSS stacking context that is important\n   * take this DOM for example:\n   * body\n   *   section[z-index: 1000]\n   *     p[z-index: 500]\n   *       button\n   *   div\n   *\n   * what z-index does the `div` need to display next to `button`?\n   * the `div` and `section` are where the stacking context splits\n   * so `div` needs to copy `section`'s z-index in order to\n   * appear next to / over `button`\n   *\n   * calculate this by starting at `button` and finding its offsetParents\n   * then walk the parents from top -> down until the stacking context\n   * split is found, or if there is no split then a specific z-index is unimportant\n   */\n  // build the array of the element + its offset parents\n  var nodesToInspect = [];\n\n  while (true) {\n    nodesToInspect.push(element); // AFAICT this is a valid cast - the libdefs appear wrong\n\n    element = element.offsetParent; // stop if there is no parent\n\n    if (element == null) {\n      break;\n    } // stop if the parent contains the related element\n    // as this is the z-index ancestor\n\n\n    if (element.contains(cousin)) {\n      break;\n    }\n  } // reverse the nodes to walk from top -> element\n\n\n  nodesToInspect.reverse();\n\n  for (var _i = 0, _nodesToInspect = nodesToInspect; _i < _nodesToInspect.length; _i++) {\n    var node = _nodesToInspect[_i]; // get this node's z-index css value\n\n    var zIndex = window.document.defaultView.getComputedStyle(node).getPropertyValue('z-index'); // if the z-index is not a number (e.g. \"auto\") return null, else the value\n\n    var parsedZIndex = parseInt(zIndex, 10);\n\n    if (!isNaN(parsedZIndex)) {\n      return parsedZIndex;\n    }\n  }\n\n  return 0;\n}","map":{"version":3,"sources":["/home/nadaanbaalak/greendeck/client/node_modules/@elastic/eui/es/services/popover/popover_positioning.js"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","POSITIONS","relatedDimension","top","right","bottom","left","dimensionPositionAttribute","height","width","positionComplements","positionSubstitutes","findPopoverPosition","_ref","anchor","popover","align","position","forcePosition","_ref$buffer","buffer","_ref$offset","offset","_ref$allowCrossAxis","allowCrossAxis","container","arrowConfig","returnBoundingBox","anchorBoundingBox","getElementBoundingBox","popoverBoundingBox","documentWidth","document","documentElement","clientWidth","window","innerWidth","documentHeight","clientHeight","innerHeight","windowBoundingBox","containerBoundingBox","iterationPositions","iterationAlignments","push","undefined","bestFit","bestPosition","idx","length","iterationPosition","screenCoordinates","getPopoverScreenCoordinates","fit","pageYOffset","pageXOffset","arrow","Error","_ref2","_popoverPlacement","_ref3","_ref2$offset","_ref2$buffer","crossAxisFirstSide","crossAxisSecondSide","crossAxisDimension","_getCrossAxisPosition","getCrossAxisPosition","crossAxisPosition","crossAxisArrowPosition","primaryAxisDimension","primaryAxisPositionName","_getPrimaryAxisPositi","getPrimaryAxisPosition","primaryAxisPosition","primaryAxisArrowPosition","popoverPlacement","combinedBoundingBox","intersectBoundingBoxes","getVisibleFit","_ref4","popoverSizeOnCrossAxis","anchorSizeOnCrossAxis","anchorHalfSize","crossAxisPositionOriginal","availableSpace","getAvailableSpace","minimumSpace","arrowBuffer","contentOverflowSize","alignAmount","alignDirection","amountOfShiftNeeded","shiftDirection","alignedOverflowAmount","needsShift","spaceAvailableOnFirstSide","spaceAvailableOnSecondSide","isShiftTowardFirstSide","leastAvailableSpace","Math","min","_needsShift","shiftAmount","arrowWidth","difference","edge","_difference","_ref5","isOffsetDecreasing","popoverSizeOnPrimaryAxis","anchorEdgeOrigin","anchorSizeOnPrimaryAxis","primaryAxisOffset","contentOffset","element","rect","getBoundingClientRect","offsetSide","contentBoundingBox","intersection","intersectionArea","contentArea","firstBox","secondBox","max","getElementZIndex","cousin","nodesToInspect","offsetParent","contains","reverse","_i","_nodesToInspect","node","zIndex","defaultView","getComputedStyle","getPropertyValue","parsedZIndex","parseInt","isNaN"],"mappings":"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","sourcesContent":["function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nexport var POSITIONS = ['top', 'right', 'bottom', 'left'];\nvar relatedDimension = {\n  top: 'height',\n  right: 'width',\n  bottom: 'height',\n  left: 'width'\n};\nvar dimensionPositionAttribute = {\n  height: 'top',\n  width: 'left'\n};\nvar positionComplements = {\n  top: 'bottom',\n  right: 'left',\n  bottom: 'top',\n  left: 'right'\n}; // always resolving to top/left is taken advantage of by knowing they are the\n// minimum edges of the bounding box\n\nvar positionSubstitutes = {\n  top: 'left',\n  right: 'top',\n  bottom: 'left',\n  left: 'top'\n};\n\n/**\n * Calculates the absolute positioning (relative to document.body) to place a popover element\n *\n * @param anchor {HTMLElement} Element to anchor the popover to\n * @param popover {HTMLElement} Element containing the popover content\n * @param position {string} Position the user wants. One of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param [forcePosition] {boolean} If true, use only the provided `position` value and don't try any other position\n * @param [align] {string} Cross-axis alignment. One of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param [buffer=16] {number} Minimum distance between the popover and the bounding container\n * @param [offset=0] {number} Distance between the popover and the anchor\n * @param [allowCrossAxis=true] {boolean} Whether to allow the popover to be positioned on the cross-axis\n * @param [container] {HTMLElement} Element the popover must be constrained to fit within\n * @param [arrowConfig] {{arrowWidth: number, arrowBuffer: number}} If\n *  present, describes the size & constraints for an arrow element, and the\n *  function return value will include an `arrow` param with position details\n *\n * @returns {FindPopoverPositionResult} absolute page coordinates for the\n * popover, and the placement's relation to the anchor or undefined\n * there's no room.\n */\nexport function findPopoverPosition(_ref) {\n  var anchor = _ref.anchor,\n      popover = _ref.popover,\n      align = _ref.align,\n      position = _ref.position,\n      forcePosition = _ref.forcePosition,\n      _ref$buffer = _ref.buffer,\n      buffer = _ref$buffer === void 0 ? 16 : _ref$buffer,\n      _ref$offset = _ref.offset,\n      offset = _ref$offset === void 0 ? 0 : _ref$offset,\n      _ref$allowCrossAxis = _ref.allowCrossAxis,\n      allowCrossAxis = _ref$allowCrossAxis === void 0 ? true : _ref$allowCrossAxis,\n      container = _ref.container,\n      arrowConfig = _ref.arrowConfig,\n      returnBoundingBox = _ref.returnBoundingBox;\n  // find the screen-relative bounding boxes of the anchor, popover, and container\n  var anchorBoundingBox = getElementBoundingBox(anchor);\n  var popoverBoundingBox = getElementBoundingBox(popover); // calculate the window's bounds\n  // window.(innerWidth|innerHeight) do not account for scrollbars\n  // so prefer the clientWidth/clientHeight of the DOM if available\n\n  var documentWidth = document.documentElement.clientWidth || window.innerWidth;\n  var documentHeight = document.documentElement.clientHeight || window.innerHeight;\n  var windowBoundingBox = {\n    top: 0,\n    right: documentWidth,\n    bottom: documentHeight,\n    left: 0,\n    height: documentHeight,\n    width: documentWidth\n  }; // if no container element is given fall back to using the window viewport\n\n  var containerBoundingBox = container ? getElementBoundingBox(container) : windowBoundingBox;\n  /**\n   * `position` was specified by the function caller and is a strong hint\n   * as to the preferred location of the popover relative to the anchor.\n   * However, we strongly prefer showing all of the popover content within\n   * the window+container boundary and will iterate over the four\n   * possible sides until a perfect fit is located. If none of the locations\n   * fully contain popover, the location with the best fit is selected.\n   *\n   * This approach first checks the preferred `position`, then its opposite\n   * along the same axis, next a location on the cross-axis, and finally it\n   * tests the remaining position.\n   *\n   * e.g.\n   * if position = \"top\" the order is top, bottom, left right\n   * if position = \"right\" the order is right, left, top, bottom\n   */\n  // Try the user-desired position first.\n\n  var iterationPositions = [position]; // keep user-defined alignment in the original positions.\n\n  var iterationAlignments = [align];\n\n  if (forcePosition !== true) {\n    iterationPositions.push(positionComplements[position]); // Try the complementary position.\n\n    iterationAlignments.push(align); // keep user-defined alignment in the complementary position.\n\n    if (allowCrossAxis) {\n      iterationPositions.push(positionSubstitutes[position], // Switch to the cross axis.\n      positionComplements[positionSubstitutes[position]] // Try the complementary position on the cross axis.\n      );\n      iterationAlignments.push(undefined, undefined); // discard desired alignment on cross-axis\n    }\n  } else {\n    // position is forced, if it conflicts with the alignment then reset align to `null`\n    // e.g. original placement request for `downLeft` is moved to the `left` side, future calls\n    // will position and align `left`, and `leftLeft` is not a valid placement\n    if (position === align || align !== undefined && position === positionComplements[align]) {\n      iterationAlignments[0] = undefined;\n    }\n  }\n\n  var bestFit = undefined;\n  var bestPosition = null;\n\n  for (var idx = 0; idx < iterationPositions.length; idx++) {\n    var iterationPosition = iterationPositions[idx]; // See if we can find a position with a better fit than we've found so far.\n\n    var screenCoordinates = getPopoverScreenCoordinates({\n      position: iterationPosition,\n      align: iterationAlignments[idx],\n      anchorBoundingBox: anchorBoundingBox,\n      popoverBoundingBox: popoverBoundingBox,\n      windowBoundingBox: windowBoundingBox,\n      containerBoundingBox: containerBoundingBox,\n      offset: offset,\n      buffer: buffer,\n      arrowConfig: arrowConfig\n    });\n\n    if (bestFit === undefined || screenCoordinates.fit > bestFit) {\n      bestFit = screenCoordinates.fit;\n      bestPosition = {\n        fit: screenCoordinates.fit,\n        position: iterationPosition,\n        top: screenCoordinates.top + window.pageYOffset,\n        left: screenCoordinates.left + window.pageXOffset,\n        arrow: screenCoordinates.arrow\n      }; // If we've already found the ideal fit, use that position.\n\n      if (bestFit === 1) {\n        break;\n      }\n    } // If we haven't improved the fit, then continue on and try a new position.\n\n  }\n\n  if (bestPosition == null) {\n    throw new Error('Failed to calculate bestPosition');\n  }\n\n  if (returnBoundingBox) {\n    bestPosition.anchorBoundingBox = anchorBoundingBox;\n  }\n\n  return bestPosition;\n}\n\n/**\n * Given a target position and the popover's surrounding context, returns either an\n * object with {top, left} screen coordinates or `null` if it's not possible to show\n * content in the target position\n * @param position {string} the target position, one of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param align {string} target alignment on the cross-axis, one of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param anchorBoundingBox {Object} bounding box of the anchor element\n * @param popoverBoundingBox {Object} bounding box of the popover element\n * @param windowBoundingBox {Object} bounding box of the window\n * @param containerBoundingBox {Object} bounding box of the container\n * @param [arrowConfig] {{arrowWidth: number, arrowBuffer: number}} If present, describes the size &\n *  constraints for an arrow element, and the function return value will include an `arrow` param\n *  with position details\n * @param [offset=0] {number} Distance between the popover and the anchor\n * @param [buffer=0] {number} Minimum distance between the popover's\n *  placement and the container edge\n *\n * @returns {GetPopoverScreenCoordinatesResult}\n *  object with top/left coordinates, the popover's relative position to the anchor, and how well the\n *  popover fits in the location (0.0 -> 1.0) coordinates and the popover's relative position, if\n *  there is no room in this placement then null\n */\nexport function getPopoverScreenCoordinates(_ref2) {\n  var _popoverPlacement, _ref3;\n\n  var position = _ref2.position,\n      align = _ref2.align,\n      anchorBoundingBox = _ref2.anchorBoundingBox,\n      popoverBoundingBox = _ref2.popoverBoundingBox,\n      windowBoundingBox = _ref2.windowBoundingBox,\n      containerBoundingBox = _ref2.containerBoundingBox,\n      arrowConfig = _ref2.arrowConfig,\n      _ref2$offset = _ref2.offset,\n      offset = _ref2$offset === void 0 ? 0 : _ref2$offset,\n      _ref2$buffer = _ref2.buffer,\n      buffer = _ref2$buffer === void 0 ? 0 : _ref2$buffer;\n\n  /**\n   * The goal is to find the best way to align the popover content\n   * on the given side of the anchor element. The popover prefers\n   * centering on the anchor but can shift along the cross-axis as needed.\n   *\n   * We return the top/left coordinates that best fit the popover inside\n   * the given boundaries, and also return the `fit` value which indicates\n   * what percentage of the popover is within the bounds.\n   *\n   * e.g. finding a location when position=top\n   * the preferred location is directly over the anchor\n   *\n   *        +----------------------+\n   *        |       popover        |\n   *        +----------------------+\n   *                   v\n   *            +--------------+\n   *            |    anchor    |\n   *            +--------------+\n   *\n   * but if anchor doesn't have much (or any) room on its ride side\n   * the popover will shift to the left\n   *\n   *    +----------------------+\n   *    |       popover        |\n   *    +----------------------+\n   *                   v\n   *            +--------------+\n   *            |    anchor    |\n   *            +--------------+\n   *\n   */\n  var crossAxisFirstSide = positionSubstitutes[position]; // \"top\" -> \"left\"\n\n  var crossAxisSecondSide = positionComplements[crossAxisFirstSide]; // \"left\" -> \"right\"\n\n  var crossAxisDimension = relatedDimension[crossAxisFirstSide]; // \"left\" -> \"width\"\n\n  var _getCrossAxisPosition = getCrossAxisPosition({\n    crossAxisFirstSide: crossAxisFirstSide,\n    crossAxisSecondSide: crossAxisSecondSide,\n    crossAxisDimension: crossAxisDimension,\n    position: position,\n    align: align,\n    buffer: buffer,\n    offset: offset,\n    windowBoundingBox: windowBoundingBox,\n    containerBoundingBox: containerBoundingBox,\n    popoverBoundingBox: popoverBoundingBox,\n    anchorBoundingBox: anchorBoundingBox,\n    arrowConfig: arrowConfig\n  }),\n      crossAxisPosition = _getCrossAxisPosition.crossAxisPosition,\n      crossAxisArrowPosition = _getCrossAxisPosition.crossAxisArrowPosition;\n\n  var primaryAxisDimension = relatedDimension[position]; // \"top\" -> \"height\"\n\n  var primaryAxisPositionName = dimensionPositionAttribute[primaryAxisDimension]; // \"height\" -> \"top\"\n\n  var _getPrimaryAxisPositi = getPrimaryAxisPosition({\n    position: position,\n    offset: offset,\n    popoverBoundingBox: popoverBoundingBox,\n    anchorBoundingBox: anchorBoundingBox,\n    arrowConfig: arrowConfig\n  }),\n      primaryAxisPosition = _getPrimaryAxisPositi.primaryAxisPosition,\n      primaryAxisArrowPosition = _getPrimaryAxisPositi.primaryAxisArrowPosition;\n\n  var popoverPlacement = (_popoverPlacement = {}, _defineProperty(_popoverPlacement, crossAxisFirstSide, crossAxisPosition), _defineProperty(_popoverPlacement, primaryAxisPositionName, primaryAxisPosition), _popoverPlacement); // calculate the fit of the popover in this location\n  // fit is in range 0.0 -> 1.0 and is the percentage of the popover which is visible in this location\n\n  var combinedBoundingBox = intersectBoundingBoxes(windowBoundingBox, containerBoundingBox); // shrink the visible bounding box by `buffer`\n  // to compute a fit value\n\n  combinedBoundingBox.top += buffer;\n  combinedBoundingBox.right -= buffer;\n  combinedBoundingBox.bottom -= buffer;\n  combinedBoundingBox.left += buffer;\n  var fit = getVisibleFit({\n    top: popoverPlacement.top,\n    right: popoverPlacement.left + popoverBoundingBox.width,\n    bottom: popoverPlacement.top + popoverBoundingBox.height,\n    left: popoverPlacement.left,\n    width: popoverBoundingBox.width,\n    height: popoverBoundingBox.height\n  }, combinedBoundingBox);\n  var arrow = arrowConfig ? (_ref3 = {}, _defineProperty(_ref3, crossAxisFirstSide, crossAxisArrowPosition - popoverPlacement[crossAxisFirstSide]), _defineProperty(_ref3, primaryAxisPositionName, primaryAxisArrowPosition), _ref3) : undefined;\n  return {\n    fit: fit,\n    top: popoverPlacement.top,\n    left: popoverPlacement.left,\n    arrow: arrow ? {\n      left: arrow.left,\n      top: arrow.top\n    } : undefined\n  };\n}\n\nfunction getCrossAxisPosition(_ref4) {\n  var crossAxisFirstSide = _ref4.crossAxisFirstSide,\n      crossAxisSecondSide = _ref4.crossAxisSecondSide,\n      crossAxisDimension = _ref4.crossAxisDimension,\n      position = _ref4.position,\n      align = _ref4.align,\n      buffer = _ref4.buffer,\n      offset = _ref4.offset,\n      windowBoundingBox = _ref4.windowBoundingBox,\n      containerBoundingBox = _ref4.containerBoundingBox,\n      popoverBoundingBox = _ref4.popoverBoundingBox,\n      anchorBoundingBox = _ref4.anchorBoundingBox,\n      arrowConfig = _ref4.arrowConfig;\n  // how much of the popover overflows past either side of the anchor if its centered\n  var popoverSizeOnCrossAxis = popoverBoundingBox[crossAxisDimension];\n  var anchorSizeOnCrossAxis = anchorBoundingBox[crossAxisDimension];\n  var anchorHalfSize = anchorSizeOnCrossAxis / 2; // the popover's original position on the cross-axis is determined by:\n\n  var crossAxisPositionOriginal = anchorBoundingBox[crossAxisFirstSide] + // where the anchor is located\n  anchorHalfSize - // plus half anchor dimension\n  popoverSizeOnCrossAxis / 2; // less half the popover dimension\n  // To fit the content within both the window and container,\n  // compute the smaller of the two spaces along each edge\n\n  var combinedBoundingBox = intersectBoundingBoxes(windowBoundingBox, containerBoundingBox);\n  var availableSpace = getAvailableSpace(anchorBoundingBox, combinedBoundingBox, buffer, offset, position);\n  var minimumSpace = arrowConfig ? arrowConfig.arrowBuffer : 0;\n  var contentOverflowSize = (popoverSizeOnCrossAxis - anchorSizeOnCrossAxis) / 2;\n  var alignAmount = 0;\n  var alignDirection = 1;\n  var amountOfShiftNeeded = 0;\n  var shiftDirection = 1;\n\n  if (align != null) {\n    // no alignment, find how much the container boundary requires the content to shift\n    alignDirection = align === 'top' || align === 'left' ? 1 : -1;\n    alignAmount = contentOverflowSize;\n    var alignedOverflowAmount = contentOverflowSize + alignAmount;\n    var needsShift = alignedOverflowAmount > availableSpace[positionComplements[align]];\n    amountOfShiftNeeded = needsShift ? alignedOverflowAmount - availableSpace[positionComplements[align]] : 0;\n    shiftDirection = -1 * alignDirection;\n  } else {\n    // shifting the popover to one side may yield a better fit\n    var spaceAvailableOnFirstSide = availableSpace[crossAxisFirstSide];\n    var spaceAvailableOnSecondSide = availableSpace[crossAxisSecondSide];\n    var isShiftTowardFirstSide = spaceAvailableOnFirstSide > spaceAvailableOnSecondSide;\n    shiftDirection = isShiftTowardFirstSide ? -1 : 1; // determine which direction has more room and the popover should shift to\n\n    var leastAvailableSpace = Math.min(spaceAvailableOnFirstSide, spaceAvailableOnSecondSide);\n\n    var _needsShift = contentOverflowSize > leastAvailableSpace;\n\n    amountOfShiftNeeded = _needsShift ? contentOverflowSize - leastAvailableSpace : 0;\n  } // shift over the popover if necessary\n\n\n  var shiftAmount = amountOfShiftNeeded * shiftDirection;\n  var crossAxisPosition = crossAxisPositionOriginal + shiftAmount + alignAmount * alignDirection; // if an `arrowConfig` is specified, find where to position the arrow\n\n  var crossAxisArrowPosition;\n\n  if (arrowConfig) {\n    var arrowWidth = arrowConfig.arrowWidth;\n    crossAxisArrowPosition = anchorBoundingBox[crossAxisFirstSide] + anchorHalfSize - arrowWidth / 2; // make sure there's enough buffer around the arrow\n    // by calculating how how much the arrow would need to move\n    // but instead of moving the arrow, shift the popover content\n\n    if (crossAxisArrowPosition < crossAxisPosition + minimumSpace) {\n      // arrow is too close to the minimum side\n      var difference = crossAxisPosition + minimumSpace - crossAxisArrowPosition;\n      crossAxisPosition -= difference;\n    } else if (crossAxisArrowPosition + minimumSpace + arrowWidth > crossAxisPosition + popoverSizeOnCrossAxis) {\n      // arrow is too close to the maximum side\n      var edge = crossAxisPosition + popoverSizeOnCrossAxis;\n\n      var _difference = crossAxisArrowPosition - (edge - minimumSpace - arrowWidth);\n\n      crossAxisPosition += _difference;\n    }\n  }\n\n  return {\n    crossAxisPosition: crossAxisPosition,\n    crossAxisArrowPosition: crossAxisArrowPosition\n  };\n}\n\nfunction getPrimaryAxisPosition(_ref5) {\n  var position = _ref5.position,\n      offset = _ref5.offset,\n      popoverBoundingBox = _ref5.popoverBoundingBox,\n      anchorBoundingBox = _ref5.anchorBoundingBox,\n      arrowConfig = _ref5.arrowConfig;\n  // if positioning to the top or left, the target position decreases\n  // from the anchor's top or left, otherwise the position adds to the anchor's\n  var isOffsetDecreasing = position === 'top' || position === 'left';\n  var primaryAxisDimension = relatedDimension[position]; // \"top\" -> \"height\"\n\n  var popoverSizeOnPrimaryAxis = popoverBoundingBox[primaryAxisDimension]; // start at the top or left edge of the anchor element\n\n  var primaryAxisPositionName = dimensionPositionAttribute[primaryAxisDimension]; // \"height\" -> \"top\"\n\n  var anchorEdgeOrigin = anchorBoundingBox[primaryAxisPositionName]; // find the popover position on the primary axis\n\n  var anchorSizeOnPrimaryAxis = anchorBoundingBox[primaryAxisDimension];\n  var primaryAxisOffset = isOffsetDecreasing ? popoverSizeOnPrimaryAxis : anchorSizeOnPrimaryAxis;\n  var contentOffset = (offset + primaryAxisOffset) * (isOffsetDecreasing ? -1 : 1);\n  var primaryAxisPosition = anchorEdgeOrigin + contentOffset;\n  var primaryAxisArrowPosition;\n\n  if (arrowConfig) {\n    primaryAxisArrowPosition = isOffsetDecreasing ? popoverSizeOnPrimaryAxis : 0;\n  }\n\n  return {\n    primaryAxisPosition: primaryAxisPosition,\n    primaryAxisArrowPosition: primaryAxisArrowPosition\n  };\n}\n/**\n * Finds the client pixel coordinate of each edge for the element's bounding box,\n * and the bounding box's width & height\n *\n * @param {HTMLElement} element\n * @returns {{top: number, right: number, bottom: number, left: number, height: number, width: number}}\n */\n\n\nexport function getElementBoundingBox(element) {\n  var rect = element.getBoundingClientRect();\n  return {\n    top: rect.top,\n    right: rect.right,\n    bottom: rect.bottom,\n    left: rect.left,\n    height: rect.height,\n    width: rect.width\n  };\n}\n/**\n * Calculates the available content space between anchor and container\n *\n * @param {Object} anchorBoundingBox Client bounding box of the anchor element\n * @param {Object} containerBoundingBox Client bounding box of the container element\n * @param {number} buffer Minimum distance between the popover and the bounding container\n * @param {number} offset Distance between the popover and the anchor\n * @param {string} offsetSide Side the offset needs to be applied to, one\n *  of [\"top\", \"right\", \"bottom\", \"left\"]\n * @returns {{top: number, right: number, bottom: number, left: number}}\n */\n\nexport function getAvailableSpace(anchorBoundingBox, containerBoundingBox, buffer, offset, offsetSide) {\n  return {\n    top: anchorBoundingBox.top - containerBoundingBox.top - buffer - (offsetSide === 'top' ? offset : 0),\n    right: containerBoundingBox.right - anchorBoundingBox.right - buffer - (offsetSide === 'right' ? offset : 0),\n    bottom: containerBoundingBox.bottom - anchorBoundingBox.bottom - buffer - (offsetSide === 'bottom' ? offset : 0),\n    left: anchorBoundingBox.left - containerBoundingBox.left - buffer - (offsetSide === 'left' ? offset : 0)\n  };\n}\n/**\n * Computes the fit (overlap) of the content within the container, fit is in range 0.0 => 1.0\n * @param contentBoundingBox bounding box of content to calculate fit for\n * @param containerBoundingBox bounding box of container\n * @returns {number}\n */\n\nexport function getVisibleFit(contentBoundingBox, containerBoundingBox) {\n  var intersection = intersectBoundingBoxes(contentBoundingBox, containerBoundingBox);\n\n  if (intersection.left > intersection.right || intersection.top > intersection.top) {\n    // there is no intersection, the boxes are completely separated on at least one axis\n    return 0;\n  }\n\n  var intersectionArea = (intersection.right - intersection.left) * (intersection.bottom - intersection.top);\n  var contentArea = (contentBoundingBox.right - contentBoundingBox.left) * (contentBoundingBox.bottom - contentBoundingBox.top);\n  return intersectionArea / contentArea;\n}\n/**\n * Calculates the intersection space between two bounding boxes\n *\n * @param firstBox\n * @param secondBox\n * @returns {EuiClientRect}\n */\n\nexport function intersectBoundingBoxes(firstBox, secondBox) {\n  var top = Math.max(firstBox.top, secondBox.top);\n  var right = Math.min(firstBox.right, secondBox.right);\n  var bottom = Math.min(firstBox.bottom, secondBox.bottom);\n  var left = Math.max(firstBox.left, secondBox.left);\n  var height = Math.max(bottom - top, 0);\n  var width = Math.max(right - left, 0);\n  return {\n    top: top,\n    right: right,\n    bottom: bottom,\n    left: left,\n    height: height,\n    width: width\n  };\n}\n/**\n * Returns the top-most defined z-index in the element's ancestor hierarchy\n * relative to the `target` element; if no z-index is defined, returns 0\n * @param element {HTMLElement}\n * @param cousin {HTMLElement}\n * @returns {number}\n */\n\nexport function getElementZIndex(element, cousin) {\n  /**\n   * finding the z-index of `element` is not the full story\n   * its the CSS stacking context that is important\n   * take this DOM for example:\n   * body\n   *   section[z-index: 1000]\n   *     p[z-index: 500]\n   *       button\n   *   div\n   *\n   * what z-index does the `div` need to display next to `button`?\n   * the `div` and `section` are where the stacking context splits\n   * so `div` needs to copy `section`'s z-index in order to\n   * appear next to / over `button`\n   *\n   * calculate this by starting at `button` and finding its offsetParents\n   * then walk the parents from top -> down until the stacking context\n   * split is found, or if there is no split then a specific z-index is unimportant\n   */\n  // build the array of the element + its offset parents\n  var nodesToInspect = [];\n\n  while (true) {\n    nodesToInspect.push(element); // AFAICT this is a valid cast - the libdefs appear wrong\n\n    element = element.offsetParent; // stop if there is no parent\n\n    if (element == null) {\n      break;\n    } // stop if the parent contains the related element\n    // as this is the z-index ancestor\n\n\n    if (element.contains(cousin)) {\n      break;\n    }\n  } // reverse the nodes to walk from top -> element\n\n\n  nodesToInspect.reverse();\n\n  for (var _i = 0, _nodesToInspect = nodesToInspect; _i < _nodesToInspect.length; _i++) {\n    var node = _nodesToInspect[_i];\n    // get this node's z-index css value\n    var zIndex = window.document.defaultView.getComputedStyle(node).getPropertyValue('z-index'); // if the z-index is not a number (e.g. \"auto\") return null, else the value\n\n    var parsedZIndex = parseInt(zIndex, 10);\n\n    if (!isNaN(parsedZIndex)) {\n      return parsedZIndex;\n    }\n  }\n\n  return 0;\n}"]},"metadata":{},"sourceType":"module"}