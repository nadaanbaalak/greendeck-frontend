{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\nimport { printIso8601 } from './date_format';\nimport { isDateValue, dateValue } from './date_value';\nimport { AST } from './ast';\nimport { isArray, isDateLike, isString } from '../../../services/predicate';\nimport { keysOf } from '../../common';\n\nvar processDateOperation = function processDateOperation(value, operator) {\n  var granularity = value.granularity,\n      resolve = value.resolve;\n  var expression = printIso8601(resolve());\n\n  if (!granularity) {\n    return {\n      operator: operator,\n      expression: expression\n    };\n  }\n\n  switch (operator) {\n    case AST.Operator.GT:\n      expression = \"\".concat(expression, \"||+1\").concat(granularity.es, \"/\").concat(granularity.es);\n      return {\n        operator: AST.Operator.GTE,\n        expression: expression\n      };\n\n    case AST.Operator.GTE:\n      expression = \"\".concat(expression, \"||/\").concat(granularity.es);\n      return {\n        operator: operator,\n        expression: expression\n      };\n\n    case AST.Operator.LT:\n      expression = \"\".concat(expression, \"||/\").concat(granularity.es);\n      return {\n        operator: operator,\n        expression: expression\n      };\n\n    case AST.Operator.LTE:\n      expression = \"\".concat(expression, \"||+1\").concat(granularity.es, \"/\").concat(granularity.es);\n      return {\n        operator: AST.Operator.LT,\n        expression: expression\n      };\n\n    default:\n      expression = \"\".concat(expression, \"||/\").concat(granularity.es);\n      return {\n        expression: expression\n      };\n  }\n};\n\nexport var _termValuesToQuery = function _termValuesToQuery(values, options) {\n  var body = {\n    query: values.join(' ')\n  };\n\n  if (body.query === '') {\n    return;\n  }\n\n  if (options.defaultFields) {\n    body.fields = options.defaultFields;\n  }\n\n  return {\n    simple_query_string: body\n  };\n};\nexport var _fieldValuesToQuery = function _fieldValuesToQuery(field, operations, andOr) {\n  var queries = [];\n  keysOf(operations).forEach(function (operator) {\n    var values = operations[operator];\n\n    switch (operator) {\n      case AST.Operator.EQ:\n        var _terms = [];\n        var phrases = [];\n        var dates = [];\n        values.forEach(function (value) {\n          if (isDateValue(value)) {\n            dates.push(value);\n          } else if (isDateLike(value)) {\n            dates.push(dateValue(value));\n          } else if (isString(value) && value.match(/\\s/)) {\n            phrases.push(value);\n          } else {\n            _terms.push(value);\n          }\n        });\n\n        if (_terms.length > 0) {\n          queries.push({\n            match: _defineProperty({}, field, {\n              query: _terms.join(' '),\n              operator: andOr\n            })\n          });\n        }\n\n        if (phrases.length > 0) {\n          queries.push.apply(queries, _toConsumableArray(phrases.map(function (phrase) {\n            return {\n              match_phrase: _defineProperty({}, field, phrase)\n            };\n          })));\n        }\n\n        if (dates.length > 0) {\n          queries.push.apply(queries, _toConsumableArray(dates.map(function (value) {\n            return {\n              match: _defineProperty({}, field, processDateOperation(value).expression)\n            };\n          })));\n        }\n\n        break;\n\n      default:\n        values.forEach(function (value) {\n          if (isDateValue(value)) {\n            var operation = processDateOperation(value, operator);\n            queries.push({\n              range: _defineProperty({}, field, _defineProperty({}, operation.operator, operation.expression))\n            });\n          } else {\n            queries.push({\n              range: _defineProperty({}, field, _defineProperty({}, operator, value))\n            });\n          }\n        });\n    }\n  });\n\n  if (queries.length === 1) {\n    return queries[0];\n  }\n\n  var key = andOr === 'and' ? 'must' : 'should';\n  return {\n    bool: _defineProperty({}, key, [].concat(queries))\n  };\n};\nexport var _isFlagToQuery = function _isFlagToQuery(flag, on) {\n  return {\n    term: _defineProperty({}, flag, on)\n  };\n};\n\nvar collectTerms = function collectTerms(clauses) {\n  var values = {\n    must: [],\n    mustNot: []\n  };\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = clauses[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var clause = _step.value;\n\n      if (AST.Match.isMustClause(clause)) {\n        values.must.push(clause.value);\n      } else {\n        values.mustNot.push(clause.value);\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return values;\n};\n\nvar collectFields = function collectFields(clauses) {\n  var fieldArray = function fieldArray(obj, field, operator) {\n    if (!obj[field]) {\n      obj[field] = {};\n    }\n\n    if (!obj[field][operator]) {\n      obj[field][operator] = [];\n    }\n\n    return obj[field][operator];\n  };\n\n  return clauses.reduce(function (fields, clause) {\n    if (AST.Match.isMustClause(clause)) {\n      if (isArray(clause.value)) {\n        var _fieldArray;\n\n        (_fieldArray = fieldArray(fields.must.or, clause.field, clause.operator)).push.apply(_fieldArray, _toConsumableArray(clause.value));\n      } else {\n        fieldArray(fields.must.and, clause.field, clause.operator).push(clause.value);\n      }\n    } else {\n      if (isArray(clause.value)) {\n        var _fieldArray2;\n\n        (_fieldArray2 = fieldArray(fields.mustNot.or, clause.field, clause.operator)).push.apply(_fieldArray2, _toConsumableArray(clause.value));\n      } else {\n        fieldArray(fields.mustNot.and, clause.field, clause.operator).push(clause.value);\n      }\n    }\n\n    return fields;\n  }, {\n    must: {\n      and: {},\n      or: {}\n    },\n    mustNot: {\n      and: {},\n      or: {}\n    }\n  });\n};\n\nvar clausesToEsQueryDsl = function clausesToEsQueryDsl(_ref) {\n  var fields = _ref.fields,\n      terms = _ref.terms,\n      is = _ref.is;\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var extraMustQueries = options.extraMustQueries || [];\n  var extraMustNotQueries = options.extraMustNotQueries || [];\n  var termValuesToQuery = options.termValuesToQuery || _termValuesToQuery;\n  var fieldValuesToQuery = options.fieldValuesToQuery || _fieldValuesToQuery;\n  var isFlagToQuery = options.isFlagToQuery || _isFlagToQuery;\n  var must = [];\n  must.push.apply(must, _toConsumableArray(extraMustQueries));\n  var termMustQuery = termValuesToQuery(terms.must, options);\n\n  if (termMustQuery) {\n    must.push(termMustQuery);\n  }\n\n  Object.keys(fields.must.and).forEach(function (field) {\n    must.push(fieldValuesToQuery(field, fields.must.and[field], 'and'));\n  });\n  Object.keys(fields.must.or).forEach(function (field) {\n    must.push(fieldValuesToQuery(field, fields.must.or[field], 'or'));\n  });\n  is.forEach(function (clause) {\n    must.push(isFlagToQuery(clause.flag, AST.Match.isMustClause(clause)));\n  });\n  var mustNot = [];\n  mustNot.push.apply(mustNot, _toConsumableArray(extraMustNotQueries));\n  var termMustNotQuery = termValuesToQuery(terms.mustNot, options);\n\n  if (termMustNotQuery) {\n    mustNot.push(termMustNotQuery);\n  }\n\n  Object.keys(fields.mustNot.and).forEach(function (field) {\n    mustNot.push(fieldValuesToQuery(field, fields.mustNot.and[field], 'and'));\n  });\n  Object.keys(fields.mustNot.or).forEach(function (field) {\n    mustNot.push(fieldValuesToQuery(field, fields.mustNot.or[field], 'or'));\n  });\n  var bool = {};\n\n  if (must.length !== 0) {\n    bool.must = must;\n  }\n\n  if (mustNot.length !== 0) {\n    bool.must_not = mustNot;\n  }\n\n  return bool;\n};\n\nvar EMPTY_TERMS = {\n  must: [],\n  mustNot: []\n};\nvar EMPTY_FIELDS = {\n  must: {\n    and: {},\n    or: {}\n  },\n  mustNot: {\n    and: {},\n    or: {}\n  }\n};\nexport var astToEsQueryDsl = function astToEsQueryDsl(ast) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (ast.clauses.length === 0) {\n    return {\n      match_all: {}\n    };\n  }\n\n  var terms = collectTerms(ast.getTermClauses());\n  var fields = collectFields(ast.getFieldClauses());\n  var is = ast.getIsClauses();\n  var matchesBool = clausesToEsQueryDsl({\n    terms: terms,\n    fields: fields,\n    is: is\n  }, options);\n  var hasTopMatches = Object.keys(matchesBool).length > 0;\n  var groupClauses = ast.getGroupClauses();\n\n  if (groupClauses.length === 0) {\n    // there are no GroupClauses, everything at top level is combined as a must\n    return {\n      bool: matchesBool\n    };\n  } else {\n    // there is at least one GroupClause, wrap the above clauses in another layer and append the ORs\n    var must = groupClauses.reduce(function (must, groupClause) {\n      var clauses = groupClause.value.reduce(function (clauses, clause) {\n        if (AST.Term.isInstance(clause)) {\n          clauses.push(clausesToEsQueryDsl({\n            terms: collectTerms([clause]),\n            fields: EMPTY_FIELDS,\n            is: []\n          }));\n        } else if (AST.Field.isInstance(clause)) {\n          clauses.push(clausesToEsQueryDsl({\n            terms: EMPTY_TERMS,\n            fields: collectFields([clause]),\n            is: []\n          }));\n        } else if (AST.Is.isInstance(clause)) {\n          clauses.push(clausesToEsQueryDsl({\n            terms: EMPTY_TERMS,\n            fields: EMPTY_FIELDS,\n            is: [clause]\n          }));\n        }\n\n        return clauses;\n      }, []);\n      must.push({\n        bool: {\n          should: clauses.map(function (clause) {\n            return {\n              bool: clause\n            };\n          })\n        }\n      });\n      return must;\n    }, hasTopMatches // only include the first match group if there are any conditions\n    ? [{\n      bool: matchesBool\n    }] : []);\n    return {\n      bool: {\n        must: must\n      }\n    };\n  }\n};","map":{"version":3,"sources":["/home/nadaanbaalak/greendeck/client/node_modules/@elastic/eui/es/components/search_bar/query/ast_to_es_query_dsl.js"],"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Object","prototype","toString","call","Array","from","isArray","i","arr2","length","_defineProperty","obj","key","value","defineProperty","enumerable","configurable","writable","printIso8601","isDateValue","dateValue","AST","isDateLike","isString","keysOf","processDateOperation","operator","granularity","resolve","expression","Operator","GT","concat","es","GTE","LT","LTE","_termValuesToQuery","values","options","body","query","join","defaultFields","fields","simple_query_string","_fieldValuesToQuery","field","operations","andOr","queries","forEach","EQ","_terms","phrases","dates","push","match","apply","map","phrase","match_phrase","operation","range","bool","_isFlagToQuery","flag","on","term","collectTerms","clauses","must","mustNot","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","_step","next","done","clause","Match","isMustClause","err","return","collectFields","fieldArray","reduce","_fieldArray","or","and","_fieldArray2","clausesToEsQueryDsl","_ref","terms","is","arguments","extraMustQueries","extraMustNotQueries","termValuesToQuery","fieldValuesToQuery","isFlagToQuery","termMustQuery","keys","termMustNotQuery","must_not","EMPTY_TERMS","EMPTY_FIELDS","astToEsQueryDsl","ast","match_all","getTermClauses","getFieldClauses","getIsClauses","matchesBool","hasTopMatches","groupClauses","getGroupClauses","groupClause","Term","isInstance","Field","Is","should"],"mappings":"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","sourcesContent":["function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { printIso8601 } from './date_format';\nimport { isDateValue, dateValue } from './date_value';\nimport { AST } from './ast';\nimport { isArray, isDateLike, isString } from '../../../services/predicate';\nimport { keysOf } from '../../common';\n\nvar processDateOperation = function processDateOperation(value, operator) {\n  var granularity = value.granularity,\n      resolve = value.resolve;\n  var expression = printIso8601(resolve());\n\n  if (!granularity) {\n    return {\n      operator: operator,\n      expression: expression\n    };\n  }\n\n  switch (operator) {\n    case AST.Operator.GT:\n      expression = \"\".concat(expression, \"||+1\").concat(granularity.es, \"/\").concat(granularity.es);\n      return {\n        operator: AST.Operator.GTE,\n        expression: expression\n      };\n\n    case AST.Operator.GTE:\n      expression = \"\".concat(expression, \"||/\").concat(granularity.es);\n      return {\n        operator: operator,\n        expression: expression\n      };\n\n    case AST.Operator.LT:\n      expression = \"\".concat(expression, \"||/\").concat(granularity.es);\n      return {\n        operator: operator,\n        expression: expression\n      };\n\n    case AST.Operator.LTE:\n      expression = \"\".concat(expression, \"||+1\").concat(granularity.es, \"/\").concat(granularity.es);\n      return {\n        operator: AST.Operator.LT,\n        expression: expression\n      };\n\n    default:\n      expression = \"\".concat(expression, \"||/\").concat(granularity.es);\n      return {\n        expression: expression\n      };\n  }\n};\n\nexport var _termValuesToQuery = function _termValuesToQuery(values, options) {\n  var body = {\n    query: values.join(' ')\n  };\n\n  if (body.query === '') {\n    return;\n  }\n\n  if (options.defaultFields) {\n    body.fields = options.defaultFields;\n  }\n\n  return {\n    simple_query_string: body\n  };\n};\nexport var _fieldValuesToQuery = function _fieldValuesToQuery(field, operations, andOr) {\n  var queries = [];\n  keysOf(operations).forEach(function (operator) {\n    var values = operations[operator];\n\n    switch (operator) {\n      case AST.Operator.EQ:\n        var _terms = [];\n        var phrases = [];\n        var dates = [];\n        values.forEach(function (value) {\n          if (isDateValue(value)) {\n            dates.push(value);\n          } else if (isDateLike(value)) {\n            dates.push(dateValue(value));\n          } else if (isString(value) && value.match(/\\s/)) {\n            phrases.push(value);\n          } else {\n            _terms.push(value);\n          }\n        });\n\n        if (_terms.length > 0) {\n          queries.push({\n            match: _defineProperty({}, field, {\n              query: _terms.join(' '),\n              operator: andOr\n            })\n          });\n        }\n\n        if (phrases.length > 0) {\n          queries.push.apply(queries, _toConsumableArray(phrases.map(function (phrase) {\n            return {\n              match_phrase: _defineProperty({}, field, phrase)\n            };\n          })));\n        }\n\n        if (dates.length > 0) {\n          queries.push.apply(queries, _toConsumableArray(dates.map(function (value) {\n            return {\n              match: _defineProperty({}, field, processDateOperation(value).expression)\n            };\n          })));\n        }\n\n        break;\n\n      default:\n        values.forEach(function (value) {\n          if (isDateValue(value)) {\n            var operation = processDateOperation(value, operator);\n            queries.push({\n              range: _defineProperty({}, field, _defineProperty({}, operation.operator, operation.expression))\n            });\n          } else {\n            queries.push({\n              range: _defineProperty({}, field, _defineProperty({}, operator, value))\n            });\n          }\n        });\n    }\n  });\n\n  if (queries.length === 1) {\n    return queries[0];\n  }\n\n  var key = andOr === 'and' ? 'must' : 'should';\n  return {\n    bool: _defineProperty({}, key, [].concat(queries))\n  };\n};\nexport var _isFlagToQuery = function _isFlagToQuery(flag, on) {\n  return {\n    term: _defineProperty({}, flag, on)\n  };\n};\n\nvar collectTerms = function collectTerms(clauses) {\n  var values = {\n    must: [],\n    mustNot: []\n  };\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = clauses[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var clause = _step.value;\n\n      if (AST.Match.isMustClause(clause)) {\n        values.must.push(clause.value);\n      } else {\n        values.mustNot.push(clause.value);\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return values;\n};\n\nvar collectFields = function collectFields(clauses) {\n  var fieldArray = function fieldArray(obj, field, operator) {\n    if (!obj[field]) {\n      obj[field] = {};\n    }\n\n    if (!obj[field][operator]) {\n      obj[field][operator] = [];\n    }\n\n    return obj[field][operator];\n  };\n\n  return clauses.reduce(function (fields, clause) {\n    if (AST.Match.isMustClause(clause)) {\n      if (isArray(clause.value)) {\n        var _fieldArray;\n\n        (_fieldArray = fieldArray(fields.must.or, clause.field, clause.operator)).push.apply(_fieldArray, _toConsumableArray(clause.value));\n      } else {\n        fieldArray(fields.must.and, clause.field, clause.operator).push(clause.value);\n      }\n    } else {\n      if (isArray(clause.value)) {\n        var _fieldArray2;\n\n        (_fieldArray2 = fieldArray(fields.mustNot.or, clause.field, clause.operator)).push.apply(_fieldArray2, _toConsumableArray(clause.value));\n      } else {\n        fieldArray(fields.mustNot.and, clause.field, clause.operator).push(clause.value);\n      }\n    }\n\n    return fields;\n  }, {\n    must: {\n      and: {},\n      or: {}\n    },\n    mustNot: {\n      and: {},\n      or: {}\n    }\n  });\n};\n\nvar clausesToEsQueryDsl = function clausesToEsQueryDsl(_ref) {\n  var fields = _ref.fields,\n      terms = _ref.terms,\n      is = _ref.is;\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var extraMustQueries = options.extraMustQueries || [];\n  var extraMustNotQueries = options.extraMustNotQueries || [];\n  var termValuesToQuery = options.termValuesToQuery || _termValuesToQuery;\n  var fieldValuesToQuery = options.fieldValuesToQuery || _fieldValuesToQuery;\n  var isFlagToQuery = options.isFlagToQuery || _isFlagToQuery;\n  var must = [];\n  must.push.apply(must, _toConsumableArray(extraMustQueries));\n  var termMustQuery = termValuesToQuery(terms.must, options);\n\n  if (termMustQuery) {\n    must.push(termMustQuery);\n  }\n\n  Object.keys(fields.must.and).forEach(function (field) {\n    must.push(fieldValuesToQuery(field, fields.must.and[field], 'and'));\n  });\n  Object.keys(fields.must.or).forEach(function (field) {\n    must.push(fieldValuesToQuery(field, fields.must.or[field], 'or'));\n  });\n  is.forEach(function (clause) {\n    must.push(isFlagToQuery(clause.flag, AST.Match.isMustClause(clause)));\n  });\n  var mustNot = [];\n  mustNot.push.apply(mustNot, _toConsumableArray(extraMustNotQueries));\n  var termMustNotQuery = termValuesToQuery(terms.mustNot, options);\n\n  if (termMustNotQuery) {\n    mustNot.push(termMustNotQuery);\n  }\n\n  Object.keys(fields.mustNot.and).forEach(function (field) {\n    mustNot.push(fieldValuesToQuery(field, fields.mustNot.and[field], 'and'));\n  });\n  Object.keys(fields.mustNot.or).forEach(function (field) {\n    mustNot.push(fieldValuesToQuery(field, fields.mustNot.or[field], 'or'));\n  });\n  var bool = {};\n\n  if (must.length !== 0) {\n    bool.must = must;\n  }\n\n  if (mustNot.length !== 0) {\n    bool.must_not = mustNot;\n  }\n\n  return bool;\n};\n\nvar EMPTY_TERMS = {\n  must: [],\n  mustNot: []\n};\nvar EMPTY_FIELDS = {\n  must: {\n    and: {},\n    or: {}\n  },\n  mustNot: {\n    and: {},\n    or: {}\n  }\n};\nexport var astToEsQueryDsl = function astToEsQueryDsl(ast) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (ast.clauses.length === 0) {\n    return {\n      match_all: {}\n    };\n  }\n\n  var terms = collectTerms(ast.getTermClauses());\n  var fields = collectFields(ast.getFieldClauses());\n  var is = ast.getIsClauses();\n  var matchesBool = clausesToEsQueryDsl({\n    terms: terms,\n    fields: fields,\n    is: is\n  }, options);\n  var hasTopMatches = Object.keys(matchesBool).length > 0;\n  var groupClauses = ast.getGroupClauses();\n\n  if (groupClauses.length === 0) {\n    // there are no GroupClauses, everything at top level is combined as a must\n    return {\n      bool: matchesBool\n    };\n  } else {\n    // there is at least one GroupClause, wrap the above clauses in another layer and append the ORs\n    var must = groupClauses.reduce(function (must, groupClause) {\n      var clauses = groupClause.value.reduce(function (clauses, clause) {\n        if (AST.Term.isInstance(clause)) {\n          clauses.push(clausesToEsQueryDsl({\n            terms: collectTerms([clause]),\n            fields: EMPTY_FIELDS,\n            is: []\n          }));\n        } else if (AST.Field.isInstance(clause)) {\n          clauses.push(clausesToEsQueryDsl({\n            terms: EMPTY_TERMS,\n            fields: collectFields([clause]),\n            is: []\n          }));\n        } else if (AST.Is.isInstance(clause)) {\n          clauses.push(clausesToEsQueryDsl({\n            terms: EMPTY_TERMS,\n            fields: EMPTY_FIELDS,\n            is: [clause]\n          }));\n        }\n\n        return clauses;\n      }, []);\n      must.push({\n        bool: {\n          should: clauses.map(function (clause) {\n            return {\n              bool: clause\n            };\n          })\n        }\n      });\n      return must;\n    }, hasTopMatches // only include the first match group if there are any conditions\n    ? [{\n      bool: matchesBool\n    }] : []);\n    return {\n      bool: {\n        must: must\n      }\n    };\n  }\n};"]},"metadata":{},"sourceType":"module"}