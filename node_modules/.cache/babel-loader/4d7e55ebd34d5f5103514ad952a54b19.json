{"ast":null,"code":"import _Object$keys from 'babel-runtime/core-js/object/keys';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _createClass from 'babel-runtime/helpers/createClass';\n/**\n * Window Sections are used to group nearby cells.\n * This enables us to more quickly determine which cells to display in a given region of the Window.\n * \n */\n\nimport Section from './Section';\nvar SECTION_SIZE = 100;\n/**\n * Contains 0 to many Sections.\n * Grows (and adds Sections) dynamically as cells are registered.\n * Automatically adds cells to the appropriate Section(s).\n */\n\nvar SectionManager = function () {\n  function SectionManager() {\n    var sectionSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SECTION_SIZE;\n\n    _classCallCheck(this, SectionManager);\n\n    this._sectionSize = sectionSize;\n    this._cellMetadata = [];\n    this._sections = {};\n  }\n  /**\n   * Gets all cell indices contained in the specified region.\n   * A region may encompass 1 or more Sections.\n   */\n\n\n  _createClass(SectionManager, [{\n    key: 'getCellIndices',\n    value: function getCellIndices(_ref) {\n      var height = _ref.height,\n          width = _ref.width,\n          x = _ref.x,\n          y = _ref.y;\n      var indices = {};\n      this.getSections({\n        height: height,\n        width: width,\n        x: x,\n        y: y\n      }).forEach(function (section) {\n        return section.getCellIndices().forEach(function (index) {\n          indices[index] = index;\n        });\n      }); // Object keys are strings; this function returns numbers\n\n      return _Object$keys(indices).map(function (index) {\n        return indices[index];\n      });\n    }\n    /** Get size and position information for the cell specified. */\n\n  }, {\n    key: 'getCellMetadata',\n    value: function getCellMetadata(_ref2) {\n      var index = _ref2.index;\n      return this._cellMetadata[index];\n    }\n    /** Get all Sections overlapping the specified region. */\n\n  }, {\n    key: 'getSections',\n    value: function getSections(_ref3) {\n      var height = _ref3.height,\n          width = _ref3.width,\n          x = _ref3.x,\n          y = _ref3.y;\n      var sectionXStart = Math.floor(x / this._sectionSize);\n      var sectionXStop = Math.floor((x + width - 1) / this._sectionSize);\n      var sectionYStart = Math.floor(y / this._sectionSize);\n      var sectionYStop = Math.floor((y + height - 1) / this._sectionSize);\n      var sections = [];\n\n      for (var sectionX = sectionXStart; sectionX <= sectionXStop; sectionX++) {\n        for (var sectionY = sectionYStart; sectionY <= sectionYStop; sectionY++) {\n          var key = sectionX + '.' + sectionY;\n\n          if (!this._sections[key]) {\n            this._sections[key] = new Section({\n              height: this._sectionSize,\n              width: this._sectionSize,\n              x: sectionX * this._sectionSize,\n              y: sectionY * this._sectionSize\n            });\n          }\n\n          sections.push(this._sections[key]);\n        }\n      }\n\n      return sections;\n    }\n    /** Total number of Sections based on the currently registered cells. */\n\n  }, {\n    key: 'getTotalSectionCount',\n    value: function getTotalSectionCount() {\n      return _Object$keys(this._sections).length;\n    }\n    /** Intended for debugger/test purposes only */\n\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var _this = this;\n\n      return _Object$keys(this._sections).map(function (index) {\n        return _this._sections[index].toString();\n      });\n    }\n    /** Adds a cell to the appropriate Sections and registers it metadata for later retrievable. */\n\n  }, {\n    key: 'registerCell',\n    value: function registerCell(_ref4) {\n      var cellMetadatum = _ref4.cellMetadatum,\n          index = _ref4.index;\n      this._cellMetadata[index] = cellMetadatum;\n      this.getSections(cellMetadatum).forEach(function (section) {\n        return section.addCellIndex({\n          index: index\n        });\n      });\n    }\n  }]);\n\n  return SectionManager;\n}();\n\nexport default SectionManager;\nimport { bpfrpt_proptype_Index } from './types';\nimport { bpfrpt_proptype_SizeAndPositionInfo } from './types';","map":{"version":3,"sources":["/home/nadaanbaalak/greendeck/client/node_modules/react-virtualized/dist/es/Collection/SectionManager.js"],"names":["_Object$keys","_classCallCheck","_createClass","Section","SECTION_SIZE","SectionManager","sectionSize","arguments","length","undefined","_sectionSize","_cellMetadata","_sections","key","value","getCellIndices","_ref","height","width","x","y","indices","getSections","forEach","section","index","map","getCellMetadata","_ref2","_ref3","sectionXStart","Math","floor","sectionXStop","sectionYStart","sectionYStop","sections","sectionX","sectionY","push","getTotalSectionCount","toString","_this","registerCell","_ref4","cellMetadatum","addCellIndex","bpfrpt_proptype_Index","bpfrpt_proptype_SizeAndPositionInfo"],"mappings":"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","sourcesContent":["import _Object$keys from 'babel-runtime/core-js/object/keys';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _createClass from 'babel-runtime/helpers/createClass';\n/**\n * Window Sections are used to group nearby cells.\n * This enables us to more quickly determine which cells to display in a given region of the Window.\n * \n */\nimport Section from './Section';\n\n\nvar SECTION_SIZE = 100;\n\n/**\n * Contains 0 to many Sections.\n * Grows (and adds Sections) dynamically as cells are registered.\n * Automatically adds cells to the appropriate Section(s).\n */\nvar SectionManager = function () {\n  function SectionManager() {\n    var sectionSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SECTION_SIZE;\n\n    _classCallCheck(this, SectionManager);\n\n    this._sectionSize = sectionSize;\n\n    this._cellMetadata = [];\n    this._sections = {};\n  }\n\n  /**\n   * Gets all cell indices contained in the specified region.\n   * A region may encompass 1 or more Sections.\n   */\n\n\n  _createClass(SectionManager, [{\n    key: 'getCellIndices',\n    value: function getCellIndices(_ref) {\n      var height = _ref.height,\n          width = _ref.width,\n          x = _ref.x,\n          y = _ref.y;\n\n      var indices = {};\n\n      this.getSections({ height: height, width: width, x: x, y: y }).forEach(function (section) {\n        return section.getCellIndices().forEach(function (index) {\n          indices[index] = index;\n        });\n      });\n\n      // Object keys are strings; this function returns numbers\n      return _Object$keys(indices).map(function (index) {\n        return indices[index];\n      });\n    }\n\n    /** Get size and position information for the cell specified. */\n\n  }, {\n    key: 'getCellMetadata',\n    value: function getCellMetadata(_ref2) {\n      var index = _ref2.index;\n\n      return this._cellMetadata[index];\n    }\n\n    /** Get all Sections overlapping the specified region. */\n\n  }, {\n    key: 'getSections',\n    value: function getSections(_ref3) {\n      var height = _ref3.height,\n          width = _ref3.width,\n          x = _ref3.x,\n          y = _ref3.y;\n\n      var sectionXStart = Math.floor(x / this._sectionSize);\n      var sectionXStop = Math.floor((x + width - 1) / this._sectionSize);\n      var sectionYStart = Math.floor(y / this._sectionSize);\n      var sectionYStop = Math.floor((y + height - 1) / this._sectionSize);\n\n      var sections = [];\n\n      for (var sectionX = sectionXStart; sectionX <= sectionXStop; sectionX++) {\n        for (var sectionY = sectionYStart; sectionY <= sectionYStop; sectionY++) {\n          var key = sectionX + '.' + sectionY;\n\n          if (!this._sections[key]) {\n            this._sections[key] = new Section({\n              height: this._sectionSize,\n              width: this._sectionSize,\n              x: sectionX * this._sectionSize,\n              y: sectionY * this._sectionSize\n            });\n          }\n\n          sections.push(this._sections[key]);\n        }\n      }\n\n      return sections;\n    }\n\n    /** Total number of Sections based on the currently registered cells. */\n\n  }, {\n    key: 'getTotalSectionCount',\n    value: function getTotalSectionCount() {\n      return _Object$keys(this._sections).length;\n    }\n\n    /** Intended for debugger/test purposes only */\n\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var _this = this;\n\n      return _Object$keys(this._sections).map(function (index) {\n        return _this._sections[index].toString();\n      });\n    }\n\n    /** Adds a cell to the appropriate Sections and registers it metadata for later retrievable. */\n\n  }, {\n    key: 'registerCell',\n    value: function registerCell(_ref4) {\n      var cellMetadatum = _ref4.cellMetadatum,\n          index = _ref4.index;\n\n      this._cellMetadata[index] = cellMetadatum;\n\n      this.getSections(cellMetadatum).forEach(function (section) {\n        return section.addCellIndex({ index: index });\n      });\n    }\n  }]);\n\n  return SectionManager;\n}();\n\nexport default SectionManager;\nimport { bpfrpt_proptype_Index } from './types';\nimport { bpfrpt_proptype_SizeAndPositionInfo } from './types';"]},"metadata":{},"sourceType":"module"}