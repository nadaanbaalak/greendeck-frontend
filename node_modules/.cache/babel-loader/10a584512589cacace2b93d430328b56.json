{"ast":null,"code":"import _slicedToArray from 'babel-runtime/helpers/slicedToArray';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _createClass from 'babel-runtime/helpers/createClass';\nimport createIntervalTree from '../vendor/intervalTree'; // Position cache requirements:\n//   O(log(n)) lookup of cells to render for a given viewport size\n//   O(1) lookup of shortest measured column (so we know when to enter phase 1)\n\nvar PositionCache = function () {\n  function PositionCache() {\n    _classCallCheck(this, PositionCache);\n\n    this._columnSizeMap = {};\n    this._intervalTree = createIntervalTree();\n    this._leftMap = {};\n  } // Tracks the height of each column\n  // Store tops and bottoms of each cell for fast intersection lookup.\n  // Maps cell index to x coordinates for quick lookup.\n\n\n  _createClass(PositionCache, [{\n    key: 'estimateTotalHeight',\n    value: function estimateTotalHeight(cellCount, columnCount, defaultCellHeight) {\n      var unmeasuredCellCount = cellCount - this.count;\n      return this.tallestColumnSize + Math.ceil(unmeasuredCellCount / columnCount) * defaultCellHeight;\n    } // Render all cells visible within the viewport range defined.\n\n  }, {\n    key: 'range',\n    value: function range(scrollTop, clientHeight, renderCallback) {\n      var _this = this;\n\n      this._intervalTree.queryInterval(scrollTop, scrollTop + clientHeight, function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 3),\n            top = _ref2[0],\n            _ = _ref2[1],\n            index = _ref2[2];\n\n        return renderCallback(index, _this._leftMap[index], top);\n      });\n    }\n  }, {\n    key: 'setPosition',\n    value: function setPosition(index, left, top, height) {\n      this._intervalTree.insert([top, top + height, index]);\n\n      this._leftMap[index] = left;\n      var columnSizeMap = this._columnSizeMap;\n      var columnHeight = columnSizeMap[left];\n\n      if (columnHeight === undefined) {\n        columnSizeMap[left] = top + height;\n      } else {\n        columnSizeMap[left] = Math.max(columnHeight, top + height);\n      }\n    }\n  }, {\n    key: 'count',\n    get: function get() {\n      return this._intervalTree.count;\n    }\n  }, {\n    key: 'shortestColumnSize',\n    get: function get() {\n      var columnSizeMap = this._columnSizeMap;\n      var size = 0;\n\n      for (var i in columnSizeMap) {\n        var height = columnSizeMap[i];\n        size = size === 0 ? height : Math.min(size, height);\n      }\n\n      return size;\n    }\n  }, {\n    key: 'tallestColumnSize',\n    get: function get() {\n      var columnSizeMap = this._columnSizeMap;\n      var size = 0;\n\n      for (var i in columnSizeMap) {\n        var height = columnSizeMap[i];\n        size = Math.max(size, height);\n      }\n\n      return size;\n    }\n  }]);\n\n  return PositionCache;\n}();\n\nexport default PositionCache;","map":{"version":3,"sources":["/home/nadaanbaalak/greendeck/client/node_modules/react-virtualized/dist/es/Masonry/PositionCache.js"],"names":["_slicedToArray","_classCallCheck","_createClass","createIntervalTree","PositionCache","_columnSizeMap","_intervalTree","_leftMap","key","value","estimateTotalHeight","cellCount","columnCount","defaultCellHeight","unmeasuredCellCount","count","tallestColumnSize","Math","ceil","range","scrollTop","clientHeight","renderCallback","_this","queryInterval","_ref","_ref2","top","_","index","setPosition","left","height","insert","columnSizeMap","columnHeight","undefined","max","get","size","i","min"],"mappings":"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","sourcesContent":["import _slicedToArray from 'babel-runtime/helpers/slicedToArray';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _createClass from 'babel-runtime/helpers/createClass';\nimport createIntervalTree from '../vendor/intervalTree';\n\n// Position cache requirements:\n//   O(log(n)) lookup of cells to render for a given viewport size\n//   O(1) lookup of shortest measured column (so we know when to enter phase 1)\nvar PositionCache = function () {\n  function PositionCache() {\n    _classCallCheck(this, PositionCache);\n\n    this._columnSizeMap = {};\n    this._intervalTree = createIntervalTree();\n    this._leftMap = {};\n  }\n  // Tracks the height of each column\n\n\n  // Store tops and bottoms of each cell for fast intersection lookup.\n\n\n  // Maps cell index to x coordinates for quick lookup.\n\n\n  _createClass(PositionCache, [{\n    key: 'estimateTotalHeight',\n    value: function estimateTotalHeight(cellCount, columnCount, defaultCellHeight) {\n      var unmeasuredCellCount = cellCount - this.count;\n      return this.tallestColumnSize + Math.ceil(unmeasuredCellCount / columnCount) * defaultCellHeight;\n    }\n\n    // Render all cells visible within the viewport range defined.\n\n  }, {\n    key: 'range',\n    value: function range(scrollTop, clientHeight, renderCallback) {\n      var _this = this;\n\n      this._intervalTree.queryInterval(scrollTop, scrollTop + clientHeight, function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 3),\n            top = _ref2[0],\n            _ = _ref2[1],\n            index = _ref2[2];\n\n        return renderCallback(index, _this._leftMap[index], top);\n      });\n    }\n  }, {\n    key: 'setPosition',\n    value: function setPosition(index, left, top, height) {\n      this._intervalTree.insert([top, top + height, index]);\n      this._leftMap[index] = left;\n\n      var columnSizeMap = this._columnSizeMap;\n      var columnHeight = columnSizeMap[left];\n      if (columnHeight === undefined) {\n        columnSizeMap[left] = top + height;\n      } else {\n        columnSizeMap[left] = Math.max(columnHeight, top + height);\n      }\n    }\n  }, {\n    key: 'count',\n    get: function get() {\n      return this._intervalTree.count;\n    }\n  }, {\n    key: 'shortestColumnSize',\n    get: function get() {\n      var columnSizeMap = this._columnSizeMap;\n\n      var size = 0;\n\n      for (var i in columnSizeMap) {\n        var height = columnSizeMap[i];\n        size = size === 0 ? height : Math.min(size, height);\n      }\n\n      return size;\n    }\n  }, {\n    key: 'tallestColumnSize',\n    get: function get() {\n      var columnSizeMap = this._columnSizeMap;\n\n      var size = 0;\n\n      for (var i in columnSizeMap) {\n        var height = columnSizeMap[i];\n        size = Math.max(size, height);\n      }\n\n      return size;\n    }\n  }]);\n\n  return PositionCache;\n}();\n\nexport default PositionCache;"]},"metadata":{},"sourceType":"module"}