{"ast":null,"code":"export var SCROLL_DIRECTION_BACKWARD = -1;\nexport var SCROLL_DIRECTION_FORWARD = 1;\nexport var SCROLL_DIRECTION_HORIZONTAL = 'horizontal';\nexport var SCROLL_DIRECTION_VERTICAL = 'vertical';\n/**\n * Calculates the number of cells to overscan before and after a specified range.\n * This function ensures that overscanning doesn't exceed the available cells.\n */\n\nexport default function defaultOverscanIndicesGetter(_ref) {\n  var cellCount = _ref.cellCount,\n      overscanCellsCount = _ref.overscanCellsCount,\n      scrollDirection = _ref.scrollDirection,\n      startIndex = _ref.startIndex,\n      stopIndex = _ref.stopIndex; // Make sure we render at least 1 cell extra before and after (except near boundaries)\n  // This is necessary in order to support keyboard navigation (TAB/SHIFT+TAB) in some cases\n  // For more info see issues #625\n\n  overscanCellsCount = Math.max(1, overscanCellsCount);\n\n  if (scrollDirection === SCROLL_DIRECTION_FORWARD) {\n    return {\n      overscanStartIndex: Math.max(0, startIndex - 1),\n      overscanStopIndex: Math.min(cellCount - 1, stopIndex + overscanCellsCount)\n    };\n  } else {\n    return {\n      overscanStartIndex: Math.max(0, startIndex - overscanCellsCount),\n      overscanStopIndex: Math.min(cellCount - 1, stopIndex + 1)\n    };\n  }\n}\nimport { bpfrpt_proptype_OverscanIndicesGetterParams } from './types';\nimport { bpfrpt_proptype_OverscanIndices } from './types';","map":{"version":3,"sources":["/home/nadaanbaalak/greendeck/client/node_modules/react-virtualized/dist/es/Grid/accessibilityOverscanIndicesGetter.js"],"names":["SCROLL_DIRECTION_BACKWARD","SCROLL_DIRECTION_FORWARD","SCROLL_DIRECTION_HORIZONTAL","SCROLL_DIRECTION_VERTICAL","defaultOverscanIndicesGetter","_ref","cellCount","overscanCellsCount","scrollDirection","startIndex","stopIndex","Math","max","overscanStartIndex","overscanStopIndex","min","bpfrpt_proptype_OverscanIndicesGetterParams","bpfrpt_proptype_OverscanIndices"],"mappings":"AAEA,OAAO,IAAIA,yBAAyB,GAAG,CAAC,CAAjC;AAEP,OAAO,IAAIC,wBAAwB,GAAG,CAA/B;AAEP,OAAO,IAAIC,2BAA2B,GAAG,YAAlC;AACP,OAAO,IAAIC,yBAAyB,GAAG,UAAhC;AAEP;;;;;AAKA,eAAe,SAASC,4BAAT,CAAsCC,IAAtC,EAA4C;AACzD,MAAIC,SAAS,GAAGD,IAAI,CAACC,SAArB;AAAA,MACIC,kBAAkB,GAAGF,IAAI,CAACE,kBAD9B;AAAA,MAEIC,eAAe,GAAGH,IAAI,CAACG,eAF3B;AAAA,MAGIC,UAAU,GAAGJ,IAAI,CAACI,UAHtB;AAAA,MAIIC,SAAS,GAAGL,IAAI,CAACK,SAJrB,CADyD,CAOzD;AACA;AACA;;AACAH,EAAAA,kBAAkB,GAAGI,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYL,kBAAZ,CAArB;;AAEA,MAAIC,eAAe,KAAKP,wBAAxB,EAAkD;AAChD,WAAO;AACLY,MAAAA,kBAAkB,EAAEF,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYH,UAAU,GAAG,CAAzB,CADf;AAELK,MAAAA,iBAAiB,EAAEH,IAAI,CAACI,GAAL,CAAST,SAAS,GAAG,CAArB,EAAwBI,SAAS,GAAGH,kBAApC;AAFd,KAAP;AAID,GALD,MAKO;AACL,WAAO;AACLM,MAAAA,kBAAkB,EAAEF,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYH,UAAU,GAAGF,kBAAzB,CADf;AAELO,MAAAA,iBAAiB,EAAEH,IAAI,CAACI,GAAL,CAAST,SAAS,GAAG,CAArB,EAAwBI,SAAS,GAAG,CAApC;AAFd,KAAP;AAID;AACF;AACD,SAASM,2CAAT,QAA4D,SAA5D;AACA,SAASC,+BAAT,QAAgD,SAAhD","sourcesContent":["\n\nexport var SCROLL_DIRECTION_BACKWARD = -1;\n\nexport var SCROLL_DIRECTION_FORWARD = 1;\n\nexport var SCROLL_DIRECTION_HORIZONTAL = 'horizontal';\nexport var SCROLL_DIRECTION_VERTICAL = 'vertical';\n\n/**\n * Calculates the number of cells to overscan before and after a specified range.\n * This function ensures that overscanning doesn't exceed the available cells.\n */\n\nexport default function defaultOverscanIndicesGetter(_ref) {\n  var cellCount = _ref.cellCount,\n      overscanCellsCount = _ref.overscanCellsCount,\n      scrollDirection = _ref.scrollDirection,\n      startIndex = _ref.startIndex,\n      stopIndex = _ref.stopIndex;\n\n  // Make sure we render at least 1 cell extra before and after (except near boundaries)\n  // This is necessary in order to support keyboard navigation (TAB/SHIFT+TAB) in some cases\n  // For more info see issues #625\n  overscanCellsCount = Math.max(1, overscanCellsCount);\n\n  if (scrollDirection === SCROLL_DIRECTION_FORWARD) {\n    return {\n      overscanStartIndex: Math.max(0, startIndex - 1),\n      overscanStopIndex: Math.min(cellCount - 1, stopIndex + overscanCellsCount)\n    };\n  } else {\n    return {\n      overscanStartIndex: Math.max(0, startIndex - overscanCellsCount),\n      overscanStopIndex: Math.min(cellCount - 1, stopIndex + 1)\n    };\n  }\n}\nimport { bpfrpt_proptype_OverscanIndicesGetterParams } from './types';\nimport { bpfrpt_proptype_OverscanIndices } from './types';"]},"metadata":{},"sourceType":"module"}