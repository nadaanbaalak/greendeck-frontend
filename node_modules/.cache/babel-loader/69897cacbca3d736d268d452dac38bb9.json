{"ast":null,"code":"import _extends from 'babel-runtime/helpers/extends';\nimport _objectWithoutProperties from 'babel-runtime/helpers/objectWithoutProperties';\nimport _Object$getPrototypeOf from 'babel-runtime/core-js/object/get-prototype-of';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _createClass from 'babel-runtime/helpers/createClass';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\nimport PropTypes from 'prop-types';\nimport * as React from 'react';\nimport CollectionView from './CollectionView';\nimport _calculateSizeAndPositionData from './utils/calculateSizeAndPositionData';\nimport getUpdatedOffsetForIndex from '../utils/getUpdatedOffsetForIndex';\n/**\n * Renders scattered or non-linear data.\n * Unlike Grid, which renders checkerboard data, Collection can render arbitrarily positioned- even overlapping- data.\n */\n\nvar Collection = function (_React$PureComponent) {\n  _inherits(Collection, _React$PureComponent);\n\n  function Collection(props, context) {\n    _classCallCheck(this, Collection);\n\n    var _this = _possibleConstructorReturn(this, (Collection.__proto__ || _Object$getPrototypeOf(Collection)).call(this, props, context));\n\n    _this._cellMetadata = [];\n    _this._lastRenderedCellIndices = []; // Cell cache during scroll (for perforamnce)\n\n    _this._cellCache = [];\n    _this._isScrollingChange = _this._isScrollingChange.bind(_this);\n    _this._setCollectionViewRef = _this._setCollectionViewRef.bind(_this);\n    return _this;\n  }\n\n  _createClass(Collection, [{\n    key: 'forceUpdate',\n    value: function forceUpdate() {\n      if (this._collectionView !== undefined) {\n        this._collectionView.forceUpdate();\n      }\n    }\n    /** See Collection#recomputeCellSizesAndPositions */\n\n  }, {\n    key: 'recomputeCellSizesAndPositions',\n    value: function recomputeCellSizesAndPositions() {\n      this._cellCache = [];\n\n      this._collectionView.recomputeCellSizesAndPositions();\n    }\n    /** React lifecycle methods */\n\n  }, {\n    key: 'render',\n    value: function render() {\n      var props = _objectWithoutProperties(this.props, []);\n\n      return React.createElement(CollectionView, _extends({\n        cellLayoutManager: this,\n        isScrollingChange: this._isScrollingChange,\n        ref: this._setCollectionViewRef\n      }, props));\n    }\n    /** CellLayoutManager interface */\n\n  }, {\n    key: 'calculateSizeAndPositionData',\n    value: function calculateSizeAndPositionData() {\n      var _props = this.props,\n          cellCount = _props.cellCount,\n          cellSizeAndPositionGetter = _props.cellSizeAndPositionGetter,\n          sectionSize = _props.sectionSize;\n\n      var data = _calculateSizeAndPositionData({\n        cellCount: cellCount,\n        cellSizeAndPositionGetter: cellSizeAndPositionGetter,\n        sectionSize: sectionSize\n      });\n\n      this._cellMetadata = data.cellMetadata;\n      this._sectionManager = data.sectionManager;\n      this._height = data.height;\n      this._width = data.width;\n    }\n    /**\n     * Returns the most recently rendered set of cell indices.\n     */\n\n  }, {\n    key: 'getLastRenderedIndices',\n    value: function getLastRenderedIndices() {\n      return this._lastRenderedCellIndices;\n    }\n    /**\n     * Calculates the minimum amount of change from the current scroll position to ensure the specified cell is (fully) visible.\n     */\n\n  }, {\n    key: 'getScrollPositionForCell',\n    value: function getScrollPositionForCell(_ref) {\n      var align = _ref.align,\n          cellIndex = _ref.cellIndex,\n          height = _ref.height,\n          scrollLeft = _ref.scrollLeft,\n          scrollTop = _ref.scrollTop,\n          width = _ref.width;\n      var cellCount = this.props.cellCount;\n\n      if (cellIndex >= 0 && cellIndex < cellCount) {\n        var cellMetadata = this._cellMetadata[cellIndex];\n        scrollLeft = getUpdatedOffsetForIndex({\n          align: align,\n          cellOffset: cellMetadata.x,\n          cellSize: cellMetadata.width,\n          containerSize: width,\n          currentOffset: scrollLeft,\n          targetIndex: cellIndex\n        });\n        scrollTop = getUpdatedOffsetForIndex({\n          align: align,\n          cellOffset: cellMetadata.y,\n          cellSize: cellMetadata.height,\n          containerSize: height,\n          currentOffset: scrollTop,\n          targetIndex: cellIndex\n        });\n      }\n\n      return {\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop\n      };\n    }\n  }, {\n    key: 'getTotalSize',\n    value: function getTotalSize() {\n      return {\n        height: this._height,\n        width: this._width\n      };\n    }\n  }, {\n    key: 'cellRenderers',\n    value: function cellRenderers(_ref2) {\n      var _this2 = this;\n\n      var height = _ref2.height,\n          isScrolling = _ref2.isScrolling,\n          width = _ref2.width,\n          x = _ref2.x,\n          y = _ref2.y;\n      var _props2 = this.props,\n          cellGroupRenderer = _props2.cellGroupRenderer,\n          cellRenderer = _props2.cellRenderer; // Store for later calls to getLastRenderedIndices()\n\n      this._lastRenderedCellIndices = this._sectionManager.getCellIndices({\n        height: height,\n        width: width,\n        x: x,\n        y: y\n      });\n      return cellGroupRenderer({\n        cellCache: this._cellCache,\n        cellRenderer: cellRenderer,\n        cellSizeAndPositionGetter: function cellSizeAndPositionGetter(_ref3) {\n          var index = _ref3.index;\n          return _this2._sectionManager.getCellMetadata({\n            index: index\n          });\n        },\n        indices: this._lastRenderedCellIndices,\n        isScrolling: isScrolling\n      });\n    }\n  }, {\n    key: '_isScrollingChange',\n    value: function _isScrollingChange(isScrolling) {\n      if (!isScrolling) {\n        this._cellCache = [];\n      }\n    }\n  }, {\n    key: '_setCollectionViewRef',\n    value: function _setCollectionViewRef(ref) {\n      this._collectionView = ref;\n    }\n  }]);\n\n  return Collection;\n}(React.PureComponent);\n\nCollection.defaultProps = {\n  'aria-label': 'grid',\n  cellGroupRenderer: defaultCellGroupRenderer\n};\nexport default Collection;\nCollection.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  'aria-label': PropTypes.string,\n\n  /**\n   * Number of cells in Collection.\n   */\n  cellCount: PropTypes.number.isRequired,\n\n  /**\n   * Responsible for rendering a group of cells given their indices.\n   * Should implement the following interface: ({\n   *   cellSizeAndPositionGetter:Function,\n   *   indices: Array<number>,\n   *   cellRenderer: Function\n   * }): Array<PropTypes.node>\n   */\n  cellGroupRenderer: PropTypes.func.isRequired,\n\n  /**\n   * Responsible for rendering a cell given an row and column index.\n   * Should implement the following interface: ({ index: number, key: string, style: object }): PropTypes.element\n   */\n  cellRenderer: PropTypes.func.isRequired,\n\n  /**\n   * Callback responsible for returning size and offset/position information for a given cell (index).\n   * ({ index: number }): { height: number, width: number, x: number, y: number }\n   */\n  cellSizeAndPositionGetter: PropTypes.func.isRequired,\n\n  /**\n   * Optionally override the size of the sections a Collection's cells are split into.\n   */\n  sectionSize: PropTypes.number\n} : {};\n\nfunction defaultCellGroupRenderer(_ref4) {\n  var cellCache = _ref4.cellCache,\n      cellRenderer = _ref4.cellRenderer,\n      cellSizeAndPositionGetter = _ref4.cellSizeAndPositionGetter,\n      indices = _ref4.indices,\n      isScrolling = _ref4.isScrolling;\n  return indices.map(function (index) {\n    var cellMetadata = cellSizeAndPositionGetter({\n      index: index\n    });\n    var cellRendererProps = {\n      index: index,\n      isScrolling: isScrolling,\n      key: index,\n      style: {\n        height: cellMetadata.height,\n        left: cellMetadata.x,\n        position: 'absolute',\n        top: cellMetadata.y,\n        width: cellMetadata.width\n      }\n    }; // Avoid re-creating cells while scrolling.\n    // This can lead to the same cell being created many times and can cause performance issues for \"heavy\" cells.\n    // If a scroll is in progress- cache and reuse cells.\n    // This cache will be thrown away once scrolling complets.\n\n    if (isScrolling) {\n      if (!(index in cellCache)) {\n        cellCache[index] = cellRenderer(cellRendererProps);\n      }\n\n      return cellCache[index];\n    } else {\n      return cellRenderer(cellRendererProps);\n    }\n  }).filter(function (renderedCell) {\n    return !!renderedCell;\n  });\n}\n\nimport { bpfrpt_proptype_ScrollPosition } from './types';\nimport { bpfrpt_proptype_SizeInfo } from './types';","map":{"version":3,"sources":["/home/nadaanbaalak/greendeck/client/node_modules/react-virtualized/dist/es/Collection/Collection.js"],"names":["_extends","_objectWithoutProperties","_Object$getPrototypeOf","_classCallCheck","_createClass","_possibleConstructorReturn","_inherits","PropTypes","React","CollectionView","_calculateSizeAndPositionData","getUpdatedOffsetForIndex","Collection","_React$PureComponent","props","context","_this","__proto__","call","_cellMetadata","_lastRenderedCellIndices","_cellCache","_isScrollingChange","bind","_setCollectionViewRef","key","value","forceUpdate","_collectionView","undefined","recomputeCellSizesAndPositions","render","createElement","cellLayoutManager","isScrollingChange","ref","calculateSizeAndPositionData","_props","cellCount","cellSizeAndPositionGetter","sectionSize","data","cellMetadata","_sectionManager","sectionManager","_height","height","_width","width","getLastRenderedIndices","getScrollPositionForCell","_ref","align","cellIndex","scrollLeft","scrollTop","cellOffset","x","cellSize","containerSize","currentOffset","targetIndex","y","getTotalSize","cellRenderers","_ref2","_this2","isScrolling","_props2","cellGroupRenderer","cellRenderer","getCellIndices","cellCache","_ref3","index","getCellMetadata","indices","PureComponent","defaultProps","defaultCellGroupRenderer","propTypes","process","env","NODE_ENV","string","number","isRequired","func","_ref4","map","cellRendererProps","style","left","position","top","filter","renderedCell","bpfrpt_proptype_ScrollPosition","bpfrpt_proptype_SizeInfo"],"mappings":"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","sourcesContent":["import _extends from 'babel-runtime/helpers/extends';\nimport _objectWithoutProperties from 'babel-runtime/helpers/objectWithoutProperties';\nimport _Object$getPrototypeOf from 'babel-runtime/core-js/object/get-prototype-of';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _createClass from 'babel-runtime/helpers/createClass';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\nimport PropTypes from 'prop-types';\nimport * as React from 'react';\nimport CollectionView from './CollectionView';\nimport _calculateSizeAndPositionData from './utils/calculateSizeAndPositionData';\nimport getUpdatedOffsetForIndex from '../utils/getUpdatedOffsetForIndex';\n\n/**\n * Renders scattered or non-linear data.\n * Unlike Grid, which renders checkerboard data, Collection can render arbitrarily positioned- even overlapping- data.\n */\nvar Collection = function (_React$PureComponent) {\n  _inherits(Collection, _React$PureComponent);\n\n  function Collection(props, context) {\n    _classCallCheck(this, Collection);\n\n    var _this = _possibleConstructorReturn(this, (Collection.__proto__ || _Object$getPrototypeOf(Collection)).call(this, props, context));\n\n    _this._cellMetadata = [];\n    _this._lastRenderedCellIndices = [];\n\n    // Cell cache during scroll (for perforamnce)\n    _this._cellCache = [];\n\n    _this._isScrollingChange = _this._isScrollingChange.bind(_this);\n    _this._setCollectionViewRef = _this._setCollectionViewRef.bind(_this);\n    return _this;\n  }\n\n  _createClass(Collection, [{\n    key: 'forceUpdate',\n    value: function forceUpdate() {\n      if (this._collectionView !== undefined) {\n        this._collectionView.forceUpdate();\n      }\n    }\n\n    /** See Collection#recomputeCellSizesAndPositions */\n\n  }, {\n    key: 'recomputeCellSizesAndPositions',\n    value: function recomputeCellSizesAndPositions() {\n      this._cellCache = [];\n      this._collectionView.recomputeCellSizesAndPositions();\n    }\n\n    /** React lifecycle methods */\n\n  }, {\n    key: 'render',\n    value: function render() {\n      var props = _objectWithoutProperties(this.props, []);\n\n      return React.createElement(CollectionView, _extends({\n        cellLayoutManager: this,\n        isScrollingChange: this._isScrollingChange,\n        ref: this._setCollectionViewRef\n      }, props));\n    }\n\n    /** CellLayoutManager interface */\n\n  }, {\n    key: 'calculateSizeAndPositionData',\n    value: function calculateSizeAndPositionData() {\n      var _props = this.props,\n          cellCount = _props.cellCount,\n          cellSizeAndPositionGetter = _props.cellSizeAndPositionGetter,\n          sectionSize = _props.sectionSize;\n\n\n      var data = _calculateSizeAndPositionData({\n        cellCount: cellCount,\n        cellSizeAndPositionGetter: cellSizeAndPositionGetter,\n        sectionSize: sectionSize\n      });\n\n      this._cellMetadata = data.cellMetadata;\n      this._sectionManager = data.sectionManager;\n      this._height = data.height;\n      this._width = data.width;\n    }\n\n    /**\n     * Returns the most recently rendered set of cell indices.\n     */\n\n  }, {\n    key: 'getLastRenderedIndices',\n    value: function getLastRenderedIndices() {\n      return this._lastRenderedCellIndices;\n    }\n\n    /**\n     * Calculates the minimum amount of change from the current scroll position to ensure the specified cell is (fully) visible.\n     */\n\n  }, {\n    key: 'getScrollPositionForCell',\n    value: function getScrollPositionForCell(_ref) {\n      var align = _ref.align,\n          cellIndex = _ref.cellIndex,\n          height = _ref.height,\n          scrollLeft = _ref.scrollLeft,\n          scrollTop = _ref.scrollTop,\n          width = _ref.width;\n      var cellCount = this.props.cellCount;\n\n\n      if (cellIndex >= 0 && cellIndex < cellCount) {\n        var cellMetadata = this._cellMetadata[cellIndex];\n\n        scrollLeft = getUpdatedOffsetForIndex({\n          align: align,\n          cellOffset: cellMetadata.x,\n          cellSize: cellMetadata.width,\n          containerSize: width,\n          currentOffset: scrollLeft,\n          targetIndex: cellIndex\n        });\n\n        scrollTop = getUpdatedOffsetForIndex({\n          align: align,\n          cellOffset: cellMetadata.y,\n          cellSize: cellMetadata.height,\n          containerSize: height,\n          currentOffset: scrollTop,\n          targetIndex: cellIndex\n        });\n      }\n\n      return {\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop\n      };\n    }\n  }, {\n    key: 'getTotalSize',\n    value: function getTotalSize() {\n      return {\n        height: this._height,\n        width: this._width\n      };\n    }\n  }, {\n    key: 'cellRenderers',\n    value: function cellRenderers(_ref2) {\n      var _this2 = this;\n\n      var height = _ref2.height,\n          isScrolling = _ref2.isScrolling,\n          width = _ref2.width,\n          x = _ref2.x,\n          y = _ref2.y;\n      var _props2 = this.props,\n          cellGroupRenderer = _props2.cellGroupRenderer,\n          cellRenderer = _props2.cellRenderer;\n\n      // Store for later calls to getLastRenderedIndices()\n\n      this._lastRenderedCellIndices = this._sectionManager.getCellIndices({\n        height: height,\n        width: width,\n        x: x,\n        y: y\n      });\n\n      return cellGroupRenderer({\n        cellCache: this._cellCache,\n        cellRenderer: cellRenderer,\n        cellSizeAndPositionGetter: function cellSizeAndPositionGetter(_ref3) {\n          var index = _ref3.index;\n          return _this2._sectionManager.getCellMetadata({ index: index });\n        },\n        indices: this._lastRenderedCellIndices,\n        isScrolling: isScrolling\n      });\n    }\n  }, {\n    key: '_isScrollingChange',\n    value: function _isScrollingChange(isScrolling) {\n      if (!isScrolling) {\n        this._cellCache = [];\n      }\n    }\n  }, {\n    key: '_setCollectionViewRef',\n    value: function _setCollectionViewRef(ref) {\n      this._collectionView = ref;\n    }\n  }]);\n\n  return Collection;\n}(React.PureComponent);\n\nCollection.defaultProps = {\n  'aria-label': 'grid',\n  cellGroupRenderer: defaultCellGroupRenderer\n};\nexport default Collection;\nCollection.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  'aria-label': PropTypes.string,\n\n  /**\n   * Number of cells in Collection.\n   */\n  cellCount: PropTypes.number.isRequired,\n\n  /**\n   * Responsible for rendering a group of cells given their indices.\n   * Should implement the following interface: ({\n   *   cellSizeAndPositionGetter:Function,\n   *   indices: Array<number>,\n   *   cellRenderer: Function\n   * }): Array<PropTypes.node>\n   */\n  cellGroupRenderer: PropTypes.func.isRequired,\n\n  /**\n   * Responsible for rendering a cell given an row and column index.\n   * Should implement the following interface: ({ index: number, key: string, style: object }): PropTypes.element\n   */\n  cellRenderer: PropTypes.func.isRequired,\n\n  /**\n   * Callback responsible for returning size and offset/position information for a given cell (index).\n   * ({ index: number }): { height: number, width: number, x: number, y: number }\n   */\n  cellSizeAndPositionGetter: PropTypes.func.isRequired,\n\n  /**\n   * Optionally override the size of the sections a Collection's cells are split into.\n   */\n  sectionSize: PropTypes.number\n} : {};\n\n\nfunction defaultCellGroupRenderer(_ref4) {\n  var cellCache = _ref4.cellCache,\n      cellRenderer = _ref4.cellRenderer,\n      cellSizeAndPositionGetter = _ref4.cellSizeAndPositionGetter,\n      indices = _ref4.indices,\n      isScrolling = _ref4.isScrolling;\n\n  return indices.map(function (index) {\n    var cellMetadata = cellSizeAndPositionGetter({ index: index });\n\n    var cellRendererProps = {\n      index: index,\n      isScrolling: isScrolling,\n      key: index,\n      style: {\n        height: cellMetadata.height,\n        left: cellMetadata.x,\n        position: 'absolute',\n        top: cellMetadata.y,\n        width: cellMetadata.width\n      }\n    };\n\n    // Avoid re-creating cells while scrolling.\n    // This can lead to the same cell being created many times and can cause performance issues for \"heavy\" cells.\n    // If a scroll is in progress- cache and reuse cells.\n    // This cache will be thrown away once scrolling complets.\n    if (isScrolling) {\n      if (!(index in cellCache)) {\n        cellCache[index] = cellRenderer(cellRendererProps);\n      }\n\n      return cellCache[index];\n    } else {\n      return cellRenderer(cellRendererProps);\n    }\n  }).filter(function (renderedCell) {\n    return !!renderedCell;\n  });\n}\nimport { bpfrpt_proptype_ScrollPosition } from './types';\nimport { bpfrpt_proptype_SizeInfo } from './types';"]},"metadata":{},"sourceType":"module"}